{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuickJSAsyncWASMModule = void 0;\nconst errors_1 = require(\"./errors\");\nconst lifetime_1 = require(\"./lifetime\");\nconst module_1 = require(\"./module\");\nconst runtime_asyncify_1 = require(\"./runtime-asyncify\");\n/**\n * Asyncified version of [[QuickJSWASMModule]].\n *\n * Due to limitations of Emscripten's ASYNCIFY process, only a single async\n * function call can happen at a time across the entire WebAssembly module.\n *\n * That means that all runtimes, contexts, functions, etc created inside this\n * WebAssembly are limited to a single concurrent async action.\n * **Multiple concurrent async actions is an error.**\n *\n * To allow for multiple concurrent async actions, you must create multiple WebAssembly\n * modules.\n */\nclass QuickJSAsyncWASMModule extends module_1.QuickJSWASMModule {\n  /** @private */\n  constructor(module, ffi) {\n    super(module, ffi);\n    this.ffi = ffi;\n    this.module = module;\n  }\n  /**\n   * Create a new async runtime inside this WebAssembly module. All runtimes inside a\n   * module are limited to a single async call at a time. For multiple\n   * concurrent async actions, create multiple WebAssembly modules.\n   */\n  newRuntime(options = {}) {\n    const rt = new lifetime_1.Lifetime(this.ffi.QTS_NewRuntime(), undefined, rt_ptr => {\n      this.callbacks.deleteRuntime(rt_ptr);\n      this.ffi.QTS_FreeRuntime(rt_ptr);\n    });\n    const runtime = new runtime_asyncify_1.QuickJSAsyncRuntime({\n      module: this.module,\n      ffi: this.ffi,\n      rt,\n      callbacks: this.callbacks\n    });\n    (0, module_1.applyBaseRuntimeOptions)(runtime, options);\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader);\n    }\n    return runtime;\n  }\n  /**\n   * A simplified API to create a new [[QuickJSRuntime]] and a\n   * [[QuickJSContext]] inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  newContext(options = {}) {\n    const runtime = this.newRuntime();\n    const lifetimes = options.ownedLifetimes ? options.ownedLifetimes.concat([runtime]) : [runtime];\n    const context = runtime.newContext({\n      ...options,\n      ownedLifetimes: lifetimes\n    });\n    runtime.context = context;\n    return context;\n  }\n  /** Synchronous evalCode is not supported. */\n  evalCode() {\n    throw new errors_1.QuickJSNotImplemented(\"QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead\");\n  }\n  /**\n   * One-off evaluate code without needing to create a [[QuickJSRuntimeAsync]] or\n   * [[QuickJSContextSync]] explicitly.\n   *\n   * This version allows for asynchronous Ecmascript module loading.\n   *\n   * Note that only a single async action can occur at a time inside the entire WebAssembly module.\n   * **Multiple concurrent async actions is an error.**\n   *\n   * See the documentation for [[QuickJSWASMModule.evalCode]] for more details.\n   */\n  evalCodeAsync(code, options) {\n    // TODO: we should really figure out generator for the Promise monad...\n    return lifetime_1.Scope.withScopeAsync(async scope => {\n      const vm = scope.manage(this.newContext());\n      (0, module_1.applyModuleEvalRuntimeOptions)(vm.runtime, options);\n      const result = await vm.evalCodeAsync(code, \"eval.js\");\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1);\n      }\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error));\n        throw error;\n      }\n      const value = vm.dump(scope.manage(result.value));\n      return value;\n    });\n  }\n}\nexports.QuickJSAsyncWASMModule = QuickJSAsyncWASMModule;","map":{"version":3,"names":["errors_1","require","lifetime_1","module_1","runtime_asyncify_1","QuickJSAsyncWASMModule","QuickJSWASMModule","constructor","module","ffi","newRuntime","options","rt","Lifetime","QTS_NewRuntime","undefined","rt_ptr","callbacks","deleteRuntime","QTS_FreeRuntime","runtime","QuickJSAsyncRuntime","applyBaseRuntimeOptions","moduleLoader","setModuleLoader","newContext","lifetimes","ownedLifetimes","concat","context","evalCode","QuickJSNotImplemented","evalCodeAsync","code","Scope","withScopeAsync","scope","vm","manage","applyModuleEvalRuntimeOptions","result","memoryLimitBytes","setMemoryLimit","error","dump","value","exports"],"sources":["../ts/module-asyncify.ts"],"sourcesContent":["import { QuickJSAsyncContext } from \"./context-asyncify\"\nimport { QuickJSAsyncEmscriptenModule } from \"./emscripten-types\"\nimport { QuickJSNotImplemented } from \"./errors\"\nimport { QuickJSAsyncFFI } from \"./variants\"\nimport { Lifetime, Scope } from \"./lifetime\"\nimport {\n  applyBaseRuntimeOptions,\n  applyModuleEvalRuntimeOptions,\n  ModuleEvalOptions,\n  QuickJSWASMModule,\n} from \"./module\"\nimport { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport { AsyncRuntimeOptions, ContextOptions, RuntimeOptions } from \"./types\"\n\n/**\n * Asyncified version of [[QuickJSWASMModule]].\n *\n * Due to limitations of Emscripten's ASYNCIFY process, only a single async\n * function call can happen at a time across the entire WebAssembly module.\n *\n * That means that all runtimes, contexts, functions, etc created inside this\n * WebAssembly are limited to a single concurrent async action.\n * **Multiple concurrent async actions is an error.**\n *\n * To allow for multiple concurrent async actions, you must create multiple WebAssembly\n * modules.\n */\nexport class QuickJSAsyncWASMModule extends QuickJSWASMModule {\n  /** @private */\n  protected ffi: QuickJSAsyncFFI\n  /** @private */\n  protected module: QuickJSAsyncEmscriptenModule\n\n  /** @private */\n  constructor(module: QuickJSAsyncEmscriptenModule, ffi: QuickJSAsyncFFI) {\n    super(module, ffi)\n    this.ffi = ffi\n    this.module = module\n  }\n\n  /**\n   * Create a new async runtime inside this WebAssembly module. All runtimes inside a\n   * module are limited to a single async call at a time. For multiple\n   * concurrent async actions, create multiple WebAssembly modules.\n   */\n  override newRuntime(options: AsyncRuntimeOptions = {}): QuickJSAsyncRuntime {\n    const rt = new Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {\n      this.callbacks.deleteRuntime(rt_ptr)\n      this.ffi.QTS_FreeRuntime(rt_ptr)\n    })\n    const runtime = new QuickJSAsyncRuntime({\n      module: this.module,\n      ffi: this.ffi,\n      rt,\n      callbacks: this.callbacks,\n    })\n\n    applyBaseRuntimeOptions(runtime, options)\n\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader)\n    }\n\n    return runtime\n  }\n\n  /**\n   * A simplified API to create a new [[QuickJSRuntime]] and a\n   * [[QuickJSContext]] inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  override newContext(options: ContextOptions = {}): QuickJSAsyncContext {\n    const runtime = this.newRuntime()\n    const lifetimes = options.ownedLifetimes ? options.ownedLifetimes.concat([runtime]) : [runtime]\n    const context = runtime.newContext({ ...options, ownedLifetimes: lifetimes })\n    runtime.context = context\n    return context\n  }\n\n  /** Synchronous evalCode is not supported. */\n  override evalCode(): never {\n    throw new QuickJSNotImplemented(\"QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead\")\n  }\n\n  /**\n   * One-off evaluate code without needing to create a [[QuickJSRuntimeAsync]] or\n   * [[QuickJSContextSync]] explicitly.\n   *\n   * This version allows for asynchronous Ecmascript module loading.\n   *\n   * Note that only a single async action can occur at a time inside the entire WebAssembly module.\n   * **Multiple concurrent async actions is an error.**\n   *\n   * See the documentation for [[QuickJSWASMModule.evalCode]] for more details.\n   */\n  evalCodeAsync(code: string, options: ModuleEvalOptions): Promise<unknown> {\n    // TODO: we should really figure out generator for the Promise monad...\n    return Scope.withScopeAsync(async (scope) => {\n      const vm = scope.manage(this.newContext())\n      applyModuleEvalRuntimeOptions(vm.runtime, options)\n      const result = await vm.evalCodeAsync(code, \"eval.js\")\n\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1)\n      }\n\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error))\n        throw error\n      }\n\n      const value = vm.dump(scope.manage(result.value))\n      return value\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}