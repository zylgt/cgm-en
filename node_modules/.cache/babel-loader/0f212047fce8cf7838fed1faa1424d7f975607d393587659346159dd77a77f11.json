{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuickJSWASMModule = exports.applyModuleEvalRuntimeOptions = exports.applyBaseRuntimeOptions = exports.QuickJSModuleCallbacks = void 0;\nconst debug_1 = require(\"./debug\");\nconst errors_1 = require(\"./errors\");\nconst lifetime_1 = require(\"./lifetime\");\nconst runtime_1 = require(\"./runtime\");\nconst types_1 = require(\"./types\");\nclass QuickJSEmscriptenModuleCallbacks {\n  constructor(args) {\n    this.callFunction = args.callFunction;\n    this.shouldInterrupt = args.shouldInterrupt;\n    this.loadModuleSource = args.loadModuleSource;\n    this.normalizeModule = args.normalizeModule;\n  }\n}\n/**\n * We use static functions per module to dispatch runtime or context calls from\n * C to the host.  This class manages the indirection from a specific runtime or\n * context pointer to the appropriate callback handler.\n *\n * @private\n */\nclass QuickJSModuleCallbacks {\n  constructor(module) {\n    this.contextCallbacks = new Map();\n    this.runtimeCallbacks = new Map();\n    this.suspendedCount = 0;\n    this.cToHostCallbacks = new QuickJSEmscriptenModuleCallbacks({\n      callFunction: (asyncify, ctx, this_ptr, argc, argv, fn_id) => this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.contextCallbacks.get(ctx);\n          if (!vm) {\n            throw new Error(`QuickJSContext(ctx = ${ctx}) not found for C function call \"${fn_id}\"`);\n          }\n          return vm.callFunction(ctx, this_ptr, argc, argv, fn_id);\n        } catch (error) {\n          console.error(\"[C to host error: returning null]\", error);\n          return 0;\n        }\n      }),\n      shouldInterrupt: (asyncify, rt) => this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.runtimeCallbacks.get(rt);\n          if (!vm) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C interrupt`);\n          }\n          return vm.shouldInterrupt(rt);\n        } catch (error) {\n          console.error(\"[C to host interrupt: returning error]\", error);\n          return 1;\n        }\n      }),\n      loadModuleSource: (asyncify, rt, ctx, moduleName) => this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt);\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`);\n          }\n          const loadModule = runtimeCallbacks.loadModuleSource;\n          if (!loadModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`);\n          }\n          return loadModule(rt, ctx, moduleName);\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error);\n          return 0;\n        }\n      }),\n      normalizeModule: (asyncify, rt, ctx, moduleBaseName, moduleName) => this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt);\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`);\n          }\n          const normalizeModule = runtimeCallbacks.normalizeModule;\n          if (!normalizeModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`);\n          }\n          return normalizeModule(rt, ctx, moduleBaseName, moduleName);\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error);\n          return 0;\n        }\n      })\n    });\n    this.module = module;\n    this.module.callbacks = this.cToHostCallbacks;\n  }\n  setRuntimeCallbacks(rt, callbacks) {\n    this.runtimeCallbacks.set(rt, callbacks);\n  }\n  deleteRuntime(rt) {\n    this.runtimeCallbacks.delete(rt);\n  }\n  setContextCallbacks(ctx, callbacks) {\n    this.contextCallbacks.set(ctx, callbacks);\n  }\n  deleteContext(ctx) {\n    this.contextCallbacks.delete(ctx);\n  }\n  handleAsyncify(asyncify, fn) {\n    if (asyncify) {\n      // We must always call asyncify.handleSync around our function.\n      // This allows asyncify to resume suspended execution on the second call.\n      // Asyncify internally can detect sync behavior, and avoid suspending.\n      return asyncify.handleSleep(done => {\n        try {\n          const result = fn();\n          if (!(result instanceof Promise)) {\n            (0, debug_1.debugLog)(\"asyncify.handleSleep: not suspending:\", result);\n            done(result);\n            return;\n          }\n          // Is promise, we intend to suspend.\n          if (this.suspended) {\n            throw new errors_1.QuickJSAsyncifyError(`Already suspended at: ${this.suspended.stack}\\nAttempted to suspend at:`);\n          } else {\n            this.suspended = new errors_1.QuickJSAsyncifySuspended(`(${this.suspendedCount++})`);\n            (0, debug_1.debugLog)(\"asyncify.handleSleep: suspending:\", this.suspended);\n          }\n          result.then(resolvedResult => {\n            this.suspended = undefined;\n            (0, debug_1.debugLog)(\"asyncify.handleSleep: resolved:\", resolvedResult);\n            done(resolvedResult);\n          }, error => {\n            (0, debug_1.debugLog)(\"asyncify.handleSleep: rejected:\", error);\n            console.error(\"QuickJS: cannot handle error in suspended function\", error);\n            this.suspended = undefined;\n          });\n        } catch (error) {\n          (0, debug_1.debugLog)(\"asyncify.handleSleep: error:\", error);\n          this.suspended = undefined;\n          throw error;\n        }\n      });\n    }\n    // No asyncify - we should never return a promise.\n    const value = fn();\n    if (value instanceof Promise) {\n      throw new Error(\"Promise return value not supported in non-asyncify context.\");\n    }\n    return value;\n  }\n}\nexports.QuickJSModuleCallbacks = QuickJSModuleCallbacks;\n/**\n * Process RuntimeOptions and apply them to a QuickJSRuntime.\n * @private\n */\nfunction applyBaseRuntimeOptions(runtime, options) {\n  if (options.interruptHandler) {\n    runtime.setInterruptHandler(options.interruptHandler);\n  }\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes);\n  }\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes);\n  }\n}\nexports.applyBaseRuntimeOptions = applyBaseRuntimeOptions;\n/**\n * Process ModuleEvalOptions and apply them to a QuickJSRuntime.\n * @private\n */\nfunction applyModuleEvalRuntimeOptions(runtime, options) {\n  if (options.moduleLoader) {\n    runtime.setModuleLoader(options.moduleLoader);\n  }\n  if (options.shouldInterrupt) {\n    runtime.setInterruptHandler(options.shouldInterrupt);\n  }\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes);\n  }\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes);\n  }\n}\nexports.applyModuleEvalRuntimeOptions = applyModuleEvalRuntimeOptions;\n/**\n * This class presents a Javascript interface to QuickJS, a Javascript interpreter\n * that supports EcmaScript 2020 (ES2020).\n *\n * It wraps a single WebAssembly module containing the QuickJS library and\n * associated helper C code. WebAssembly modules are completely isolated from\n * each other by the host's WebAssembly runtime. Separate WebAssembly modules\n * have the most isolation guarantees possible with this library.\n *\n * The simplest way to start running code is {@link evalCode}. This shortcut\n * method will evaluate Javascript safely and return the result as a native\n * Javascript value.\n *\n * For more control over the execution environment, or to interact with values\n * inside QuickJS, create a context with {@link newContext} or a runtime with\n * {@link newRuntime}.\n */\nclass QuickJSWASMModule {\n  /** @private */\n  constructor(module, ffi) {\n    this.module = module;\n    this.ffi = ffi;\n    this.callbacks = new QuickJSModuleCallbacks(module);\n  }\n  /**\n   * Create a runtime.\n   * Use the runtime to set limits on CPU and memory usage and configure module\n   * loading for one or more [[QuickJSContext]]s inside the runtime.\n   */\n  newRuntime(options = {}) {\n    const rt = new lifetime_1.Lifetime(this.ffi.QTS_NewRuntime(), undefined, rt_ptr => {\n      this.callbacks.deleteRuntime(rt_ptr);\n      this.ffi.QTS_FreeRuntime(rt_ptr);\n    });\n    const runtime = new runtime_1.QuickJSRuntime({\n      module: this.module,\n      callbacks: this.callbacks,\n      ffi: this.ffi,\n      rt\n    });\n    applyBaseRuntimeOptions(runtime, options);\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader);\n    }\n    return runtime;\n  }\n  /**\n   * A simplified API to create a new [[QuickJSRuntime]] and a\n   * [[QuickJSContext]] inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  newContext(options = {}) {\n    const runtime = this.newRuntime();\n    const context = runtime.newContext({\n      ...options,\n      ownedLifetimes: (0, types_1.concat)(runtime, options.ownedLifetimes)\n    });\n    runtime.context = context;\n    return context;\n  }\n  /**\n   * One-off evaluate code without needing to create a [[QuickJSRuntime]] or\n   * [[QuickJSContext]] explicitly.\n   *\n   * To protect against infinite loops, use the `shouldInterrupt` option. The\n   * [[shouldInterruptAfterDeadline]] function will create a time-based deadline.\n   *\n   * If you need more control over how the code executes, create a\n   * [[QuickJSRuntime]] (with [[newRuntime]]) or a [[QuickJSContext]] (with\n   * [[newContext]] or [[QuickJSRuntime.newContext]]), and use its\n   * [[QuickJSContext.evalCode]] method.\n   *\n   * Asynchronous callbacks may not run during the first call to `evalCode`. If\n   * you need to work with async code inside QuickJS, create a runtime and use\n   * [[QuickJSRuntime.executePendingJobs]].\n   *\n   * @returns The result is coerced to a native Javascript value using JSON\n   * serialization, so properties and values unsupported by JSON will be dropped.\n   *\n   * @throws If `code` throws during evaluation, the exception will be\n   * converted into a native Javascript value and thrown.\n   *\n   * @throws if `options.shouldInterrupt` interrupted execution, will throw a Error\n   * with name `\"InternalError\"` and  message `\"interrupted\"`.\n   */\n  evalCode(code, options = {}) {\n    return lifetime_1.Scope.withScope(scope => {\n      const vm = scope.manage(this.newContext());\n      applyModuleEvalRuntimeOptions(vm.runtime, options);\n      const result = vm.evalCode(code, \"eval.js\");\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1);\n      }\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error));\n        throw error;\n      }\n      const value = vm.dump(scope.manage(result.value));\n      return value;\n    });\n  }\n  /**\n   * Get a low-level interface to the QuickJS functions in this WebAssembly\n   * module.\n   * @experimental\n   * @unstable No warranty is provided with this API. It could change at any time.\n   * @private\n   */\n  getFFI() {\n    return this.ffi;\n  }\n}\nexports.QuickJSWASMModule = QuickJSWASMModule;","map":{"version":3,"names":["debug_1","require","errors_1","lifetime_1","runtime_1","types_1","QuickJSEmscriptenModuleCallbacks","constructor","args","callFunction","shouldInterrupt","loadModuleSource","normalizeModule","QuickJSModuleCallbacks","module","contextCallbacks","Map","runtimeCallbacks","suspendedCount","cToHostCallbacks","asyncify","ctx","this_ptr","argc","argv","fn_id","handleAsyncify","vm","get","Error","error","console","rt","moduleName","loadModule","moduleBaseName","callbacks","setRuntimeCallbacks","set","deleteRuntime","delete","setContextCallbacks","deleteContext","fn","handleSleep","done","result","Promise","debugLog","suspended","QuickJSAsyncifyError","stack","QuickJSAsyncifySuspended","then","resolvedResult","undefined","value","exports","applyBaseRuntimeOptions","runtime","options","interruptHandler","setInterruptHandler","maxStackSizeBytes","setMaxStackSize","memoryLimitBytes","setMemoryLimit","applyModuleEvalRuntimeOptions","moduleLoader","setModuleLoader","QuickJSWASMModule","ffi","newRuntime","Lifetime","QTS_NewRuntime","rt_ptr","QTS_FreeRuntime","QuickJSRuntime","newContext","context","ownedLifetimes","concat","evalCode","code","Scope","withScope","scope","manage","dump","getFFI"],"sources":["../ts/module.ts"],"sourcesContent":["import { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport {\n  Asyncify,\n  AsyncifySleepResult,\n  EitherModule,\n  EmscriptenModuleCallbacks,\n} from \"./emscripten-types\"\nimport { QuickJSAsyncifyError, QuickJSAsyncifySuspended } from \"./errors\"\nimport {\n  BorrowedHeapCharPointer,\n  JSContextPointer,\n  JSRuntimePointer,\n  JSValuePointer,\n} from \"./types-ffi\"\nimport { Lifetime, Scope } from \"./lifetime\"\nimport { InterruptHandler, QuickJSRuntime } from \"./runtime\"\nimport {\n  AsyncRuntimeOptions,\n  concat,\n  ContextOptions,\n  EitherFFI,\n  JSModuleLoader,\n  RuntimeOptions,\n  RuntimeOptionsBase,\n} from \"./types\"\n\ntype EmscriptenCallback<BaseArgs extends any[], Result> = (\n  ...args: [Asyncify | undefined, ...BaseArgs]\n) => Result | AsyncifySleepResult<Result>\ntype MaybeAsyncEmscriptenCallback<T extends EmscriptenCallback<any, any>> =\n  T extends EmscriptenCallback<infer Args, infer Result>\n    ? (...args: Args) => Result | Promise<Result>\n    : never\ntype MaybeAsyncEmscriptenCallbacks = {\n  [K in keyof EmscriptenModuleCallbacks]: MaybeAsyncEmscriptenCallback<EmscriptenModuleCallbacks[K]>\n}\n\n/**\n * @private\n */\nexport interface ContextCallbacks {\n  callFunction: MaybeAsyncEmscriptenCallbacks[\"callFunction\"]\n}\n\n/**\n * @private\n */\nexport interface RuntimeCallbacks {\n  shouldInterrupt: MaybeAsyncEmscriptenCallbacks[\"shouldInterrupt\"]\n  loadModuleSource: MaybeAsyncEmscriptenCallbacks[\"loadModuleSource\"]\n  normalizeModule: MaybeAsyncEmscriptenCallbacks[\"normalizeModule\"]\n}\n\nclass QuickJSEmscriptenModuleCallbacks implements EmscriptenModuleCallbacks {\n  public callFunction: EmscriptenModuleCallbacks[\"callFunction\"]\n  public shouldInterrupt: EmscriptenModuleCallbacks[\"shouldInterrupt\"]\n  public loadModuleSource: EmscriptenModuleCallbacks[\"loadModuleSource\"]\n  public normalizeModule: EmscriptenModuleCallbacks[\"normalizeModule\"]\n  constructor(args: EmscriptenModuleCallbacks) {\n    this.callFunction = args.callFunction\n    this.shouldInterrupt = args.shouldInterrupt\n    this.loadModuleSource = args.loadModuleSource\n    this.normalizeModule = args.normalizeModule\n  }\n}\n\n/**\n * Options for [[QuickJSWASMModule.evalCode]].\n */\nexport interface ModuleEvalOptions {\n  /**\n   * Interrupt evaluation if `shouldInterrupt` returns `true`.\n   * See [[shouldInterruptAfterDeadline]].\n   */\n  shouldInterrupt?: InterruptHandler\n\n  /**\n   * Memory limit, in bytes, of WebAssembly heap memory used by the QuickJS VM.\n   */\n  memoryLimitBytes?: number\n\n  /**\n   * Stack size limit for this vm, in bytes\n   * To remove the limit, set to `0`.\n   */\n  maxStackSizeBytes?: number\n\n  /**\n   * Module loader for any `import` statements or expressions.\n   */\n  moduleLoader?: JSModuleLoader\n}\n\n/**\n * We use static functions per module to dispatch runtime or context calls from\n * C to the host.  This class manages the indirection from a specific runtime or\n * context pointer to the appropriate callback handler.\n *\n * @private\n */\nexport class QuickJSModuleCallbacks {\n  private module: EitherModule\n  private contextCallbacks = new Map<JSContextPointer, ContextCallbacks>()\n  private runtimeCallbacks = new Map<JSRuntimePointer, RuntimeCallbacks>()\n\n  constructor(module: EitherModule) {\n    this.module = module\n    this.module.callbacks = this.cToHostCallbacks\n  }\n\n  setRuntimeCallbacks(rt: JSRuntimePointer, callbacks: RuntimeCallbacks) {\n    this.runtimeCallbacks.set(rt, callbacks)\n  }\n\n  deleteRuntime(rt: JSRuntimePointer) {\n    this.runtimeCallbacks.delete(rt)\n  }\n\n  setContextCallbacks(ctx: JSContextPointer, callbacks: ContextCallbacks) {\n    this.contextCallbacks.set(ctx, callbacks)\n  }\n\n  deleteContext(ctx: JSContextPointer) {\n    this.contextCallbacks.delete(ctx)\n  }\n\n  private suspendedCount = 0\n  private suspended: QuickJSAsyncifySuspended | undefined\n\n  private handleAsyncify<T>(\n    asyncify: Asyncify | undefined,\n    fn: () => T | Promise<T>\n  ): T | AsyncifySleepResult<T> {\n    if (asyncify) {\n      // We must always call asyncify.handleSync around our function.\n      // This allows asyncify to resume suspended execution on the second call.\n      // Asyncify internally can detect sync behavior, and avoid suspending.\n      return asyncify.handleSleep((done) => {\n        try {\n          const result = fn()\n          if (!(result instanceof Promise)) {\n            debugLog(\"asyncify.handleSleep: not suspending:\", result)\n            done(result)\n            return\n          }\n\n          // Is promise, we intend to suspend.\n          if (this.suspended) {\n            throw new QuickJSAsyncifyError(\n              `Already suspended at: ${this.suspended.stack}\\nAttempted to suspend at:`\n            )\n          } else {\n            this.suspended = new QuickJSAsyncifySuspended(`(${this.suspendedCount++})`)\n            debugLog(\"asyncify.handleSleep: suspending:\", this.suspended)\n          }\n\n          result.then(\n            (resolvedResult) => {\n              this.suspended = undefined\n              debugLog(\"asyncify.handleSleep: resolved:\", resolvedResult)\n              done(resolvedResult)\n            },\n            (error) => {\n              debugLog(\"asyncify.handleSleep: rejected:\", error)\n              console.error(\"QuickJS: cannot handle error in suspended function\", error)\n              this.suspended = undefined\n            }\n          )\n        } catch (error) {\n          debugLog(\"asyncify.handleSleep: error:\", error)\n          this.suspended = undefined\n          throw error\n        }\n      })\n    }\n\n    // No asyncify - we should never return a promise.\n    const value = fn()\n    if (value instanceof Promise) {\n      throw new Error(\"Promise return value not supported in non-asyncify context.\")\n    }\n    return value\n  }\n\n  private cToHostCallbacks = new QuickJSEmscriptenModuleCallbacks({\n    callFunction: (asyncify, ctx, this_ptr, argc, argv, fn_id) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.contextCallbacks.get(ctx)\n          if (!vm) {\n            throw new Error(`QuickJSContext(ctx = ${ctx}) not found for C function call \"${fn_id}\"`)\n          }\n          return vm.callFunction(ctx, this_ptr, argc, argv, fn_id)\n        } catch (error) {\n          console.error(\"[C to host error: returning null]\", error)\n          return 0 as JSValuePointer\n        }\n      }),\n\n    shouldInterrupt: (asyncify, rt) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.runtimeCallbacks.get(rt)\n          if (!vm) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C interrupt`)\n          }\n          return vm.shouldInterrupt(rt)\n        } catch (error) {\n          console.error(\"[C to host interrupt: returning error]\", error)\n          return 1\n        }\n      }),\n\n    loadModuleSource: (asyncify, rt, ctx, moduleName) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt)\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`)\n          }\n\n          const loadModule = runtimeCallbacks.loadModuleSource\n          if (!loadModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`)\n          }\n          return loadModule(rt, ctx, moduleName)\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }),\n\n    normalizeModule: (asyncify, rt, ctx, moduleBaseName, moduleName) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt)\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`)\n          }\n\n          const normalizeModule = runtimeCallbacks.normalizeModule\n          if (!normalizeModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`)\n          }\n          return normalizeModule(rt, ctx, moduleBaseName, moduleName)\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }),\n  })\n}\n\n/**\n * Process RuntimeOptions and apply them to a QuickJSRuntime.\n * @private\n */\nexport function applyBaseRuntimeOptions(\n  runtime: QuickJSRuntime,\n  options: RuntimeOptionsBase\n): void {\n  if (options.interruptHandler) {\n    runtime.setInterruptHandler(options.interruptHandler)\n  }\n\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes)\n  }\n\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes)\n  }\n}\n\n/**\n * Process ModuleEvalOptions and apply them to a QuickJSRuntime.\n * @private\n */\nexport function applyModuleEvalRuntimeOptions<T extends QuickJSRuntime>(\n  runtime: T,\n  options: ModuleEvalOptions\n) {\n  if (options.moduleLoader) {\n    runtime.setModuleLoader(options.moduleLoader)\n  }\n\n  if (options.shouldInterrupt) {\n    runtime.setInterruptHandler(options.shouldInterrupt)\n  }\n\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes)\n  }\n\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes)\n  }\n}\n\n/**\n * This class presents a Javascript interface to QuickJS, a Javascript interpreter\n * that supports EcmaScript 2020 (ES2020).\n *\n * It wraps a single WebAssembly module containing the QuickJS library and\n * associated helper C code. WebAssembly modules are completely isolated from\n * each other by the host's WebAssembly runtime. Separate WebAssembly modules\n * have the most isolation guarantees possible with this library.\n *\n * The simplest way to start running code is {@link evalCode}. This shortcut\n * method will evaluate Javascript safely and return the result as a native\n * Javascript value.\n *\n * For more control over the execution environment, or to interact with values\n * inside QuickJS, create a context with {@link newContext} or a runtime with\n * {@link newRuntime}.\n */\nexport class QuickJSWASMModule {\n  /** @private */\n  protected ffi: EitherFFI\n  /** @private */\n  protected callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected module: EitherModule\n\n  /** @private */\n  constructor(module: EitherModule, ffi: EitherFFI) {\n    this.module = module\n    this.ffi = ffi\n    this.callbacks = new QuickJSModuleCallbacks(module)\n  }\n\n  /**\n   * Create a runtime.\n   * Use the runtime to set limits on CPU and memory usage and configure module\n   * loading for one or more [[QuickJSContext]]s inside the runtime.\n   */\n  newRuntime(options: RuntimeOptions = {}): QuickJSRuntime {\n    const rt = new Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {\n      this.callbacks.deleteRuntime(rt_ptr)\n      this.ffi.QTS_FreeRuntime(rt_ptr)\n    })\n\n    const runtime = new QuickJSRuntime({\n      module: this.module,\n      callbacks: this.callbacks,\n      ffi: this.ffi,\n      rt,\n    })\n\n    applyBaseRuntimeOptions(runtime, options)\n\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader)\n    }\n\n    return runtime\n  }\n\n  /**\n   * A simplified API to create a new [[QuickJSRuntime]] and a\n   * [[QuickJSContext]] inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  newContext(options: ContextOptions = {}): QuickJSContext {\n    const runtime = this.newRuntime()\n    const context = runtime.newContext({\n      ...options,\n      ownedLifetimes: concat(runtime, options.ownedLifetimes),\n    })\n    runtime.context = context\n    return context\n  }\n\n  /**\n   * One-off evaluate code without needing to create a [[QuickJSRuntime]] or\n   * [[QuickJSContext]] explicitly.\n   *\n   * To protect against infinite loops, use the `shouldInterrupt` option. The\n   * [[shouldInterruptAfterDeadline]] function will create a time-based deadline.\n   *\n   * If you need more control over how the code executes, create a\n   * [[QuickJSRuntime]] (with [[newRuntime]]) or a [[QuickJSContext]] (with\n   * [[newContext]] or [[QuickJSRuntime.newContext]]), and use its\n   * [[QuickJSContext.evalCode]] method.\n   *\n   * Asynchronous callbacks may not run during the first call to `evalCode`. If\n   * you need to work with async code inside QuickJS, create a runtime and use\n   * [[QuickJSRuntime.executePendingJobs]].\n   *\n   * @returns The result is coerced to a native Javascript value using JSON\n   * serialization, so properties and values unsupported by JSON will be dropped.\n   *\n   * @throws If `code` throws during evaluation, the exception will be\n   * converted into a native Javascript value and thrown.\n   *\n   * @throws if `options.shouldInterrupt` interrupted execution, will throw a Error\n   * with name `\"InternalError\"` and  message `\"interrupted\"`.\n   */\n  evalCode(code: string, options: ModuleEvalOptions = {}): unknown {\n    return Scope.withScope((scope) => {\n      const vm = scope.manage(this.newContext())\n\n      applyModuleEvalRuntimeOptions(vm.runtime, options)\n      const result = vm.evalCode(code, \"eval.js\")\n\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1)\n      }\n\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error))\n        throw error\n      }\n\n      const value = vm.dump(scope.manage(result.value))\n      return value\n    })\n  }\n\n  /**\n   * Get a low-level interface to the QuickJS functions in this WebAssembly\n   * module.\n   * @experimental\n   * @unstable No warranty is provided with this API. It could change at any time.\n   * @private\n   */\n  getFFI(): EitherFFI {\n    return this.ffi\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}