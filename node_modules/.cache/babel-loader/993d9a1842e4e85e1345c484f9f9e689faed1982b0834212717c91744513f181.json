{"ast":null,"code":"import { Message } from \"element-ui\";\nimport { eventBus } from '@/utils/eventBus';\nimport { generateKeys, arrayBufferToBase64, calShareKey } from '@/utils/ecdh';\nimport { aesEncrypt, aesDecrypt } from '@/utils/aes';\nlet socket = null; //实例对象\nlet lockReconnect = false; //是否真正建立连接\nlet port = [8971, 8972, 8973, 8974, 8975, 8976, 8977, 8978, 8979, 8980]; //端口号\nlet port_index = 0; //端口号下标\nlet repeat = 0; //重连次数\nlet status = 0; //连接状态 0开始建立连接 1连接成功 2交换秘钥成功 3连接失败 4连接中断\nlet share_key = null; //AES加密共享秘钥\nlet exchange_shareKey = \"com.ihealth.cgm\"; //AES加密共享秘钥\nlet privateKey = null; //私钥\n\nconst initwebSocket = async () => {\n  if (\"WebSocket\" in window) {\n    var wsUrl = 'ws://ivd.cgm3.com:' + port[port_index] + '/uploader';\n    console.log(wsUrl, '连接地址');\n    socket = new WebSocket(wsUrl);\n    status = 0;\n    socket.onerror = webSocketOnError;\n    socket.onmessage = webSocketOnMessage;\n    socket.onclose = closeWebsocket;\n    socket.onopen = openWebsocket;\n  } else {\n    Message.error({\n      showClose: true,\n      message: '您的浏览器不支持websocket，请更换Chrome或者Firefox'\n    });\n  }\n};\n\n//重置\nconst reset = () => {\n  repeat = 0;\n  status = 0;\n  port_index = 0;\n};\n//建立连接\nconst openWebsocket = async e => {\n  console.log(e, '已连接');\n  lockReconnect = true;\n  status = 1;\n  // 连接建立成功后开始协商秘钥\n  let publickey = await getEcdhPublicKey();\n  console.log(\"开始协商秘钥...\");\n  sendWebsocket({\n    \"path\": \"changekey\",\n    \"data\": {\n      \"publicKey\": publickey\n    }\n  });\n};\n// 重新连接\nconst reconnect = () => {\n  if (lockReconnect) {\n    return;\n  }\n  port_index++;\n  if (port_index > 9) {\n    port_index = 0;\n    repeat++;\n    if (repeat > 2) {\n      status = 3;\n      self.$store.dispatch('setProcedureState', 2); //驱动启动失败\n      self.$store.dispatch('setSocketState', status); //驱动启动失败\n      console.log('WebSocket 连接失败，端口都不被连接');\n      return;\n    }\n    console.log(`正在尝试第 ${repeat} 次重连...`);\n  }\n  initwebSocket();\n};\n\n// 发送数据\nconst sendWebsocket = data => {\n  if (!lockReconnect) {\n    console.log(\"webSocket未连接\");\n    return;\n  }\n  console.log(\"发送的内容: \" + JSON.stringify(data));\n  const path = data.path;\n  //对data内容加密\n  if (\"data\" in data) {\n    const key = path == \"changekey\" ? exchange_shareKey : shareKey;\n    data[\"data\"] = aesEncrypt(data[\"data\"], key);\n  }\n  let json = JSON.stringify(data);\n  socket.send(json);\n};\nconst webSocketOnError = e => {\n  console.log('发生错误', e);\n};\n// 接收数据\nconst webSocketOnMessage = async e => {\n  let info = JSON.parse(e.data);\n  let path = info.path;\n  let code = info.code;\n  if (code != 200) {\n    console.log('报错');\n    return;\n  }\n  if (path == \"changekey\") {\n    let data_info = aesDecrypt(info.data, exchange_shareKey);\n    let procedure_public_key = data_info.publicKey;\n    let share_data = await calShareKey(privateKey, procedure_public_key);\n    share_key = arrayBufferToBase64(share_data);\n    getAppInfo();\n    console.log(\"协商秘钥结果: \" + share_key + \"\\n\");\n  } else {\n    info.data = aesDecrypt(info.data, share_key);\n    handelMessage(info);\n    eventBus.$emit('socketMessage', info);\n  }\n};\nconst closeWebsocket = e => {\n  lockReconnect = false;\n  if (e.code == 1000 || e.code > 1010) {\n    console.log('连接已关闭', e);\n  } else {\n    // 异常关闭，需要重连\n    reconnect();\n  }\n};\n//断开连接\nconst close = () => {\n  //WebSocket对象也有发送和关闭的两个方法，只需要在自定义方法中分别调用send()和close()即可实现。\n  socket.close();\n};\n\n//获取公钥\nconst getEcdhPublicKey = async () => {\n  const ecdh = await generateKeys();\n  privateKey = ecdh.privateKey;\n  //导出公钥转为base64字符串\n  const public_bytes = await window.crypto.subtle.exportKey(\"raw\", ecdh.publicKey);\n  const base64_public_key = arrayBufferToBase64(public_bytes);\n  return base64_public_key;\n};\n\n//获取驱动程序的版本信息\nconst getAppInfo = () => {\n  console.log(\"获取驱动程序的版本信息\");\n  let data = {\n    \"path\": \"getAppInfo\"\n  };\n  sendWebsocket(data);\n};\n\n///获取电脑串口连接的reader设备\nconst getReaderList = () => {\n  console.log(\"获取Reader设备列表\");\n  let data = {\n    \"path\": \"getReaderDevices\"\n  };\n  sendWebsocket(data);\n};\n\n//连接Reader设备,这里默认连接设备列表的第一个设备  \nconst connectReader = device => {\n  let content = {\n    \"path\": \"connectReaderDevice\",\n    \"data\": {\n      \"reader_mac\": device.reader_mac\n    }\n  };\n  sendWebsocket(content);\n};\n\n//读取Reader设备信息\nconst getReaderInfo = () => {\n  let content = {\n    \"path\": \"getReaderDeviceInfo\"\n  };\n  sendWebsocket(content);\n};\n\n//同步时间\nconst setTime = data => {\n  let content = {\n    \"path\": \"setTime\",\n    \"data\": {\n      \"zone\": data.zone,\n      \"timestamp\": data.timestamp\n    }\n  };\n  sendWebsocket(content);\n};\nexport default {\n  initwebSocket,\n  reset,\n  getReaderList,\n  connectReader,\n  getReaderInfo,\n  setTime\n};","map":{"version":3,"names":["Message","eventBus","generateKeys","arrayBufferToBase64","calShareKey","aesEncrypt","aesDecrypt","socket","lockReconnect","port","port_index","repeat","status","share_key","exchange_shareKey","privateKey","initwebSocket","window","wsUrl","console","log","WebSocket","onerror","webSocketOnError","onmessage","webSocketOnMessage","onclose","closeWebsocket","onopen","openWebsocket","error","showClose","message","reset","e","publickey","getEcdhPublicKey","sendWebsocket","reconnect","self","$store","dispatch","data","JSON","stringify","path","key","shareKey","json","send","info","parse","code","data_info","procedure_public_key","publicKey","share_data","getAppInfo","handelMessage","$emit","close","ecdh","public_bytes","crypto","subtle","exportKey","base64_public_key","getReaderList","connectReader","device","content","reader_mac","getReaderInfo","setTime","zone","timestamp"],"sources":["/Users/hexuemin/Desktop/jiuan/CGM/CGMWeb/src/utils/webSocket.js"],"sourcesContent":["import { Message } from \"element-ui\";\nimport {eventBus} from '@/utils/eventBus'\nimport {generateKeys,arrayBufferToBase64,calShareKey} from '@/utils/ecdh'\nimport {aesEncrypt,aesDecrypt} from '@/utils/aes'\n\nlet socket = null; //实例对象\nlet lockReconnect = false; //是否真正建立连接\nlet port = [8971,8972,8973,8974,8975,8976,8977,8978,8979,8980]; //端口号\nlet port_index = 0; //端口号下标\nlet repeat = 0; //重连次数\nlet status = 0; //连接状态 0开始建立连接 1连接成功 2交换秘钥成功 3连接失败 4连接中断\nlet share_key = null //AES加密共享秘钥\nlet exchange_shareKey = \"com.ihealth.cgm\" //AES加密共享秘钥\nlet privateKey = null //私钥\n\nconst initwebSocket = async()=>{\n    if(\"WebSocket\" in window){\n        var wsUrl = 'ws://ivd.cgm3.com:'+port[port_index]+'/uploader'\n        console.log(wsUrl,'连接地址')\n        socket = new WebSocket(wsUrl);\n        status = 0\n        socket.onerror = webSocketOnError;\n        socket.onmessage = webSocketOnMessage;\n        socket.onclose = closeWebsocket;\n        socket.onopen = openWebsocket;\n    }else{\n        Message.error({\n            showClose: true,\n            message: '您的浏览器不支持websocket，请更换Chrome或者Firefox'\n        });\n    }\n}\n\n\n//重置\nconst reset = () => {\n    repeat=0\n    status=0\n    port_index = 0\n\n}\n//建立连接\nconst openWebsocket = async(e) => {\n    console.log(e,'已连接')\n    lockReconnect = true\n    status = 1\n    // 连接建立成功后开始协商秘钥\n    let publickey = await getEcdhPublicKey()\n    console.log(\"开始协商秘钥...\")\n    sendWebsocket({\"path\":\"changekey\", \"data\":{\"publicKey\":publickey}})\n}\n// 重新连接\nconst reconnect = () =>{\n    if(lockReconnect){\n        return ;\n    }\n    port_index++\n    if(port_index>9){\n        port_index = 0\n        repeat++\n        if(repeat>2){\n            status = 3\n            self.$store.dispatch('setProcedureState',2) //驱动启动失败\n            self.$store.dispatch('setSocketState',status) //驱动启动失败\n            console.log('WebSocket 连接失败，端口都不被连接');\n            return;\n        }\n        console.log(`正在尝试第 ${repeat} 次重连...`);\n    }\n    initwebSocket()\n}\n\n// 发送数据\nconst sendWebsocket =(data) =>{\n    if(!lockReconnect){\n        console.log(\"webSocket未连接\")\n        return\n    }\n    console.log(\"发送的内容: \" + JSON.stringify(data))\n    const path = data.path\n    //对data内容加密\n    if (\"data\" in data){\n        const key = path == \"changekey\" ? exchange_shareKey : shareKey\n        data[\"data\"] = aesEncrypt(data[\"data\"],key)  \n    }\n    let json = JSON.stringify(data)\n    socket.send(json)\n}\n   \n\nconst webSocketOnError = (e) => {\n    console.log('发生错误',e)\n}  \n// 接收数据\nconst webSocketOnMessage = async(e) => {\n    let info = JSON.parse(e.data)\n    let path = info.path\n    let code = info.code\n    if(code!=200){\n        console.log('报错')\n        return\n    }\n    if(path == \"changekey\"){\n        let data_info = aesDecrypt(info.data,exchange_shareKey)\n        let procedure_public_key = data_info.publicKey\n        let share_data = await calShareKey(privateKey,procedure_public_key)\n        share_key = arrayBufferToBase64(share_data)\n        getAppInfo()\n        console.log(\"协商秘钥结果: \" + share_key + \"\\n\")\n    }else{\n        info.data = aesDecrypt(info.data,share_key)\n        handelMessage(info)\n        eventBus.$emit('socketMessage',info)\n    }\n\n}\n\n\n\nconst closeWebsocket= (e) => {\n   \n    lockReconnect = false\n    if(e.code==1000||e.code>1010){\n        console.log('连接已关闭',e)\n    }else{\n        // 异常关闭，需要重连\n        reconnect();\n    }\n} \n//断开连接\nconst close = () => {\n    //WebSocket对象也有发送和关闭的两个方法，只需要在自定义方法中分别调用send()和close()即可实现。\n      socket.close();\n}   \n\n\n//获取公钥\nconst getEcdhPublicKey = async()=>{\n    const ecdh = await generateKeys()\n    privateKey = ecdh.privateKey\n    //导出公钥转为base64字符串\n    const public_bytes = await window.crypto.subtle.exportKey(\"raw\", ecdh.publicKey);\n    const base64_public_key = arrayBufferToBase64(public_bytes)\n    return base64_public_key\n}\n\n//获取驱动程序的版本信息\nconst getAppInfo = () =>{\n    console.log(\"获取驱动程序的版本信息\")\n    let data = {\"path\": \"getAppInfo\"}\n    sendWebsocket(data)\n}\n\n///获取电脑串口连接的reader设备\nconst getReaderList = () => {\n    console.log(\"获取Reader设备列表\")\n    let data = {\"path\": \"getReaderDevices\"}\n    sendWebsocket(data)\n}\n\n//连接Reader设备,这里默认连接设备列表的第一个设备  \nconst connectReader = (device) =>{\n    let content = {\"path\": \"connectReaderDevice\",\"data\":{\"reader_mac\":device.reader_mac}}\n    sendWebsocket(content)\n}\n\n//读取Reader设备信息\n const getReaderInfo = () =>{\n    let content = {\"path\": \"getReaderDeviceInfo\"}\n    sendWebsocket(content)\n}\n\n //同步时间\n const setTime = (data) =>{\n    let content = {\"path\": \"setTime\",\"data\":{\"zone\":data.zone,\"timestamp\":data.timestamp}}\n    sendWebsocket(content)\n}\n\n\n\n\nexport default {\n    initwebSocket,\n    reset,\n    getReaderList,\n    connectReader,\n    getReaderInfo,\n    setTime\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}