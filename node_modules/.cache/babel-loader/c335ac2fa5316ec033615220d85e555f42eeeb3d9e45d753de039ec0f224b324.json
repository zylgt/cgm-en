{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuickJSDeferredPromise = void 0;\n/**\n * QuickJSDeferredPromise wraps a QuickJS promise [[handle]] and allows\n * [[resolve]]ing or [[reject]]ing that promise. Use it to bridge asynchronous\n * code on the host to APIs inside a QuickJSContext.\n *\n * Managing the lifetime of promises is tricky. There are three\n * [[QuickJSHandle]]s inside of each deferred promise object: (1) the promise\n * itself, (2) the `resolve` callback, and (3) the `reject` callback.\n *\n * - If the promise will be fulfilled before the end of it's [[owner]]'s lifetime,\n *   the only cleanup necessary is `deferred.handle.dispose()`, because\n *   calling [[resolve]] or [[reject]] will dispose of both callbacks automatically.\n *\n * - As the return value of a [[VmFunctionImplementation]], return [[handle]],\n *   and ensure that either [[resolve]] or [[reject]] will be called. No other\n *   clean-up is necessary.\n *\n * - In other cases, call [[dispose]], which will dispose [[handle]] as well as the\n *   QuickJS handles that back [[resolve]] and [[reject]]. For this object,\n *   [[dispose]] is idempotent.\n */\nclass QuickJSDeferredPromise {\n  /**\n   * Use [[QuickJSContext.newPromise]] to create a new promise instead of calling\n   * this constructor directly.\n   * @unstable\n   */\n  constructor(args) {\n    /**\n     * Resolve [[handle]] with the given value, if any.\n     * Calling this method after calling [[dispose]] is a no-op.\n     *\n     * Note that after resolving a promise, you may need to call\n     * [[QuickJSContext.executePendingJobs]] to propagate the result to the promise's\n     * callbacks.\n     */\n    this.resolve = value => {\n      if (!this.resolveHandle.alive) {\n        return;\n      }\n      this.context.unwrapResult(this.context.callFunction(this.resolveHandle, this.context.undefined, value || this.context.undefined)).dispose();\n      this.disposeResolvers();\n      this.onSettled();\n    };\n    /**\n     * Reject [[handle]] with the given value, if any.\n     * Calling this method after calling [[dispose]] is a no-op.\n     *\n     * Note that after rejecting a promise, you may need to call\n     * [[QuickJSContext.executePendingJobs]] to propagate the result to the promise's\n     * callbacks.\n     */\n    this.reject = value => {\n      if (!this.rejectHandle.alive) {\n        return;\n      }\n      this.context.unwrapResult(this.context.callFunction(this.rejectHandle, this.context.undefined, value || this.context.undefined)).dispose();\n      this.disposeResolvers();\n      this.onSettled();\n    };\n    this.dispose = () => {\n      if (this.handle.alive) {\n        this.handle.dispose();\n      }\n      this.disposeResolvers();\n    };\n    this.context = args.context;\n    this.owner = args.context.runtime;\n    this.handle = args.promiseHandle;\n    this.settled = new Promise(resolve => {\n      this.onSettled = resolve;\n    });\n    this.resolveHandle = args.resolveHandle;\n    this.rejectHandle = args.rejectHandle;\n  }\n  get alive() {\n    return this.handle.alive || this.resolveHandle.alive || this.rejectHandle.alive;\n  }\n  disposeResolvers() {\n    if (this.resolveHandle.alive) {\n      this.resolveHandle.dispose();\n    }\n    if (this.rejectHandle.alive) {\n      this.rejectHandle.dispose();\n    }\n  }\n}\nexports.QuickJSDeferredPromise = QuickJSDeferredPromise;","map":{"version":3,"names":["QuickJSDeferredPromise","constructor","args","resolve","value","resolveHandle","alive","context","unwrapResult","callFunction","undefined","dispose","disposeResolvers","onSettled","reject","rejectHandle","handle","owner","runtime","promiseHandle","settled","Promise","exports"],"sources":["../ts/deferred-promise.ts"],"sourcesContent":["import type { Disposable } from \"./lifetime\"\nimport type { QuickJSHandle } from \"./types\"\nimport type { QuickJSRuntime } from \"./runtime\"\nimport type { QuickJSContext } from \"./context\"\nexport type { PromiseExecutor } from \"./types\"\n\n/**\n * QuickJSDeferredPromise wraps a QuickJS promise [[handle]] and allows\n * [[resolve]]ing or [[reject]]ing that promise. Use it to bridge asynchronous\n * code on the host to APIs inside a QuickJSContext.\n *\n * Managing the lifetime of promises is tricky. There are three\n * [[QuickJSHandle]]s inside of each deferred promise object: (1) the promise\n * itself, (2) the `resolve` callback, and (3) the `reject` callback.\n *\n * - If the promise will be fulfilled before the end of it's [[owner]]'s lifetime,\n *   the only cleanup necessary is `deferred.handle.dispose()`, because\n *   calling [[resolve]] or [[reject]] will dispose of both callbacks automatically.\n *\n * - As the return value of a [[VmFunctionImplementation]], return [[handle]],\n *   and ensure that either [[resolve]] or [[reject]] will be called. No other\n *   clean-up is necessary.\n *\n * - In other cases, call [[dispose]], which will dispose [[handle]] as well as the\n *   QuickJS handles that back [[resolve]] and [[reject]]. For this object,\n *   [[dispose]] is idempotent.\n */\nexport class QuickJSDeferredPromise implements Disposable {\n  public owner: QuickJSRuntime\n  public context: QuickJSContext\n\n  /**\n   * A handle of the Promise instance inside the QuickJSContext.\n   * You must dispose [[handle]] or the entire QuickJSDeferredPromise once you\n   * are finished with it.\n   */\n  public handle: QuickJSHandle\n\n  /**\n   * A native promise that will resolve once this deferred is settled.\n   */\n  public settled: Promise<void>\n\n  private resolveHandle: QuickJSHandle\n  private rejectHandle: QuickJSHandle\n  private onSettled!: () => void\n\n  /**\n   * Use [[QuickJSContext.newPromise]] to create a new promise instead of calling\n   * this constructor directly.\n   * @unstable\n   */\n  constructor(args: {\n    context: QuickJSContext\n    promiseHandle: QuickJSHandle\n    resolveHandle: QuickJSHandle\n    rejectHandle: QuickJSHandle\n  }) {\n    this.context = args.context\n    this.owner = args.context.runtime\n    this.handle = args.promiseHandle\n    this.settled = new Promise((resolve) => {\n      this.onSettled = resolve\n    })\n    this.resolveHandle = args.resolveHandle\n    this.rejectHandle = args.rejectHandle\n  }\n\n  /**\n   * Resolve [[handle]] with the given value, if any.\n   * Calling this method after calling [[dispose]] is a no-op.\n   *\n   * Note that after resolving a promise, you may need to call\n   * [[QuickJSContext.executePendingJobs]] to propagate the result to the promise's\n   * callbacks.\n   */\n  resolve = (value?: QuickJSHandle) => {\n    if (!this.resolveHandle.alive) {\n      return\n    }\n\n    this.context\n      .unwrapResult(\n        this.context.callFunction(\n          this.resolveHandle,\n          this.context.undefined,\n          value || this.context.undefined\n        )\n      )\n      .dispose()\n\n    this.disposeResolvers()\n    this.onSettled()\n  }\n\n  /**\n   * Reject [[handle]] with the given value, if any.\n   * Calling this method after calling [[dispose]] is a no-op.\n   *\n   * Note that after rejecting a promise, you may need to call\n   * [[QuickJSContext.executePendingJobs]] to propagate the result to the promise's\n   * callbacks.\n   */\n  reject = (value?: QuickJSHandle) => {\n    if (!this.rejectHandle.alive) {\n      return\n    }\n\n    this.context\n      .unwrapResult(\n        this.context.callFunction(\n          this.rejectHandle,\n          this.context.undefined,\n          value || this.context.undefined\n        )\n      )\n      .dispose()\n\n    this.disposeResolvers()\n    this.onSettled()\n  }\n\n  get alive() {\n    return this.handle.alive || this.resolveHandle.alive || this.rejectHandle.alive\n  }\n\n  dispose = () => {\n    if (this.handle.alive) {\n      this.handle.dispose()\n    }\n    this.disposeResolvers()\n  }\n\n  private disposeResolvers() {\n    if (this.resolveHandle.alive) {\n      this.resolveHandle.dispose()\n    }\n\n    if (this.rejectHandle.alive) {\n      this.rejectHandle.dispose()\n    }\n  }\n}\n"],"mappings":";;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;AAqBA,MAAaA,sBAAsB;EAoBjC;;;;;EAKAC,YAAYC,IAKX;IAWD;;;;;;;;IAQA,KAAAC,OAAO,GAAIC,KAAqB,IAAI;MAClC,IAAI,CAAC,IAAI,CAACC,aAAa,CAACC,KAAK,EAAE;QAC7B;;MAGF,IAAI,CAACC,OAAO,CACTC,YAAY,CACX,IAAI,CAACD,OAAO,CAACE,YAAY,CACvB,IAAI,CAACJ,aAAa,EAClB,IAAI,CAACE,OAAO,CAACG,SAAS,EACtBN,KAAK,IAAI,IAAI,CAACG,OAAO,CAACG,SAAS,CAChC,CACF,CACAC,OAAO,EAAE;MAEZ,IAAI,CAACC,gBAAgB,EAAE;MACvB,IAAI,CAACC,SAAS,EAAE;IAClB,CAAC;IAED;;;;;;;;IAQA,KAAAC,MAAM,GAAIV,KAAqB,IAAI;MACjC,IAAI,CAAC,IAAI,CAACW,YAAY,CAACT,KAAK,EAAE;QAC5B;;MAGF,IAAI,CAACC,OAAO,CACTC,YAAY,CACX,IAAI,CAACD,OAAO,CAACE,YAAY,CACvB,IAAI,CAACM,YAAY,EACjB,IAAI,CAACR,OAAO,CAACG,SAAS,EACtBN,KAAK,IAAI,IAAI,CAACG,OAAO,CAACG,SAAS,CAChC,CACF,CACAC,OAAO,EAAE;MAEZ,IAAI,CAACC,gBAAgB,EAAE;MACvB,IAAI,CAACC,SAAS,EAAE;IAClB,CAAC;IAMD,KAAAF,OAAO,GAAG,MAAK;MACb,IAAI,IAAI,CAACK,MAAM,CAACV,KAAK,EAAE;QACrB,IAAI,CAACU,MAAM,CAACL,OAAO,EAAE;;MAEvB,IAAI,CAACC,gBAAgB,EAAE;IACzB,CAAC;IAzEC,IAAI,CAACL,OAAO,GAAGL,IAAI,CAACK,OAAO;IAC3B,IAAI,CAACU,KAAK,GAAGf,IAAI,CAACK,OAAO,CAACW,OAAO;IACjC,IAAI,CAACF,MAAM,GAAGd,IAAI,CAACiB,aAAa;IAChC,IAAI,CAACC,OAAO,GAAG,IAAIC,OAAO,CAAElB,OAAO,IAAI;MACrC,IAAI,CAACU,SAAS,GAAGV,OAAO;IAC1B,CAAC,CAAC;IACF,IAAI,CAACE,aAAa,GAAGH,IAAI,CAACG,aAAa;IACvC,IAAI,CAACU,YAAY,GAAGb,IAAI,CAACa,YAAY;EACvC;EAwDA,IAAIT,KAAKA,CAAA;IACP,OAAO,IAAI,CAACU,MAAM,CAACV,KAAK,IAAI,IAAI,CAACD,aAAa,CAACC,KAAK,IAAI,IAAI,CAACS,YAAY,CAACT,KAAK;EACjF;EASQM,gBAAgBA,CAAA;IACtB,IAAI,IAAI,CAACP,aAAa,CAACC,KAAK,EAAE;MAC5B,IAAI,CAACD,aAAa,CAACM,OAAO,EAAE;;IAG9B,IAAI,IAAI,CAACI,YAAY,CAACT,KAAK,EAAE;MAC3B,IAAI,CAACS,YAAY,CAACJ,OAAO,EAAE;;EAE/B;;AAlHFW,OAAA,CAAAtB,sBAAA,GAAAA,sBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}