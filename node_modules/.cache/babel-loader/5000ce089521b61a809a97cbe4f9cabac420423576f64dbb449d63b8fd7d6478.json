{"ast":null,"code":"const b4a = require('b4a');\n\n/**\n * https://encoding.spec.whatwg.org/#utf-8-decoder\n */\nmodule.exports = class UTF8Decoder {\n  constructor() {\n    this.codePoint = 0;\n    this.bytesSeen = 0;\n    this.bytesNeeded = 0;\n    this.lowerBoundary = 0x80;\n    this.upperBoundary = 0xbf;\n  }\n  decode(data) {\n    // If we have a fast path, just sniff if the last part is a boundary\n    if (this.bytesNeeded === 0) {\n      let isBoundary = true;\n      for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {\n        isBoundary = data[i] <= 0x7f;\n      }\n      if (isBoundary) return b4a.toString(data, 'utf8');\n    }\n    let result = '';\n    for (let i = 0, n = data.byteLength; i < n; i++) {\n      const byte = data[i];\n      if (this.bytesNeeded === 0) {\n        if (byte <= 0x7f) {\n          result += String.fromCharCode(byte);\n        } else if (byte >= 0xc2 && byte <= 0xdf) {\n          this.bytesNeeded = 1;\n          this.codePoint = byte & 0x1f;\n        } else if (byte >= 0xe0 && byte <= 0xef) {\n          if (byte === 0xe0) this.lowerBoundary = 0xa0;else if (byte === 0xed) this.upperBoundary = 0x9f;\n          this.bytesNeeded = 2;\n          this.codePoint = byte & 0xf;\n        } else if (byte >= 0xf0 && byte <= 0xf4) {\n          if (byte === 0xf0) this.lowerBoundary = 0x90;\n          if (byte === 0xf4) this.upperBoundary = 0x8f;\n          this.bytesNeeded = 3;\n          this.codePoint = byte & 0x7;\n        } else {\n          result += '\\ufffd';\n        }\n        continue;\n      }\n      if (byte < this.lowerBoundary || byte > this.upperBoundary) {\n        this.codePoint = 0;\n        this.bytesNeeded = 0;\n        this.bytesSeen = 0;\n        this.lowerBoundary = 0x80;\n        this.upperBoundary = 0xbf;\n        result += '\\ufffd';\n        continue;\n      }\n      this.lowerBoundary = 0x80;\n      this.upperBoundary = 0xbf;\n      this.codePoint = this.codePoint << 6 | byte & 0x3f;\n      this.bytesSeen++;\n      if (this.bytesSeen !== this.bytesNeeded) continue;\n      result += String.fromCodePoint(this.codePoint);\n      this.codePoint = 0;\n      this.bytesNeeded = 0;\n      this.bytesSeen = 0;\n    }\n    return result;\n  }\n  flush() {\n    const result = this.bytesNeeded > 0 ? '\\ufffd' : '';\n    this.codePoint = 0;\n    this.bytesNeeded = 0;\n    this.bytesSeen = 0;\n    this.lowerBoundary = 0x80;\n    this.upperBoundary = 0xbf;\n    return result;\n  }\n};","map":{"version":3,"names":["b4a","require","module","exports","UTF8Decoder","constructor","codePoint","bytesSeen","bytesNeeded","lowerBoundary","upperBoundary","decode","data","isBoundary","i","Math","max","byteLength","n","toString","result","byte","String","fromCharCode","fromCodePoint","flush"],"sources":["/Users/hexuemin/Desktop/jiuan/CGM/CGMWeb/node_modules/text-decoder/lib/utf8-decoder.js"],"sourcesContent":["const b4a = require('b4a')\n\n/**\n * https://encoding.spec.whatwg.org/#utf-8-decoder\n */\nmodule.exports = class UTF8Decoder {\n  constructor () {\n    this.codePoint = 0\n    this.bytesSeen = 0\n    this.bytesNeeded = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n  }\n\n  decode (data) {\n    // If we have a fast path, just sniff if the last part is a boundary\n    if (this.bytesNeeded === 0) {\n      let isBoundary = true\n\n      for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {\n        isBoundary = data[i] <= 0x7f\n      }\n\n      if (isBoundary) return b4a.toString(data, 'utf8')\n    }\n\n    let result = ''\n\n    for (let i = 0, n = data.byteLength; i < n; i++) {\n      const byte = data[i]\n\n      if (this.bytesNeeded === 0) {\n        if (byte <= 0x7f) {\n          result += String.fromCharCode(byte)\n        } else if (byte >= 0xc2 && byte <= 0xdf) {\n          this.bytesNeeded = 1\n          this.codePoint = byte & 0x1f\n        } else if (byte >= 0xe0 && byte <= 0xef) {\n          if (byte === 0xe0) this.lowerBoundary = 0xa0\n          else if (byte === 0xed) this.upperBoundary = 0x9f\n          this.bytesNeeded = 2\n          this.codePoint = byte & 0xf\n        } else if (byte >= 0xf0 && byte <= 0xf4) {\n          if (byte === 0xf0) this.lowerBoundary = 0x90\n          if (byte === 0xf4) this.upperBoundary = 0x8f\n          this.bytesNeeded = 3\n          this.codePoint = byte & 0x7\n        } else {\n          result += '\\ufffd'\n        }\n\n        continue\n      }\n\n      if (byte < this.lowerBoundary || byte > this.upperBoundary) {\n        this.codePoint = 0\n        this.bytesNeeded = 0\n        this.bytesSeen = 0\n        this.lowerBoundary = 0x80\n        this.upperBoundary = 0xbf\n\n        result += '\\ufffd'\n\n        continue\n      }\n\n      this.lowerBoundary = 0x80\n      this.upperBoundary = 0xbf\n\n      this.codePoint = (this.codePoint << 6) | (byte & 0x3f)\n      this.bytesSeen++\n\n      if (this.bytesSeen !== this.bytesNeeded) continue\n\n      result += String.fromCodePoint(this.codePoint)\n\n      this.codePoint = 0\n      this.bytesNeeded = 0\n      this.bytesSeen = 0\n    }\n\n    return result\n  }\n\n  flush () {\n    const result = this.bytesNeeded > 0 ? '\\ufffd' : ''\n\n    this.codePoint = 0\n    this.bytesNeeded = 0\n    this.bytesSeen = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n\n    return result\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}