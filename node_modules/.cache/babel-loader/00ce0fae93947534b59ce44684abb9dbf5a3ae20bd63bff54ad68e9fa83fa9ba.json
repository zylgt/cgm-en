{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/web.url-search-params.delete.js\");\nrequire(\"core-js/modules/web.url-search-params.has.js\");\nrequire(\"core-js/modules/web.url-search-params.size.js\");\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getUri = exports.isValidProtocol = exports.protocols = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\n// Built-in protocols\nconst data_1 = require(\"./data\");\nconst file_1 = require(\"./file\");\nconst ftp_1 = require(\"./ftp\");\nconst http_1 = require(\"./http\");\nconst https_1 = require(\"./https\");\nconst debug = (0, debug_1.default)('get-uri');\nexports.protocols = {\n  data: data_1.data,\n  file: file_1.file,\n  ftp: ftp_1.ftp,\n  http: http_1.http,\n  https: https_1.https\n};\nconst VALID_PROTOCOLS = new Set(Object.keys(exports.protocols));\nfunction isValidProtocol(p) {\n  return VALID_PROTOCOLS.has(p);\n}\nexports.isValidProtocol = isValidProtocol;\n/**\n * Async function that returns a `stream.Readable` instance that will output\n * the contents of the given URI.\n *\n * For caching purposes, you can pass in a `stream` instance from a previous\n * `getUri()` call as a `cache: stream` option, and if the destination has\n * not changed since the last time the endpoint was retreived then the callback\n * will be invoked with an Error object with `code` set to \"ENOTMODIFIED\" and\n * `null` for the \"stream\" instance argument. In this case, you can skip\n * retreiving the file again and continue to use the previous payload.\n *\n * @param {String} uri URI to retrieve\n * @param {Object} opts optional \"options\" object\n * @api public\n */\nasync function getUri(uri, opts) {\n  debug('getUri(%o)', uri);\n  if (!uri) {\n    throw new TypeError('Must pass in a URI to \"getUri()\"');\n  }\n  const url = typeof uri === 'string' ? new URL(uri) : uri;\n  // Strip trailing `:`\n  const protocol = url.protocol.replace(/:$/, '');\n  if (!isValidProtocol(protocol)) {\n    throw new TypeError(`Unsupported protocol \"${protocol}\" specified in URI: \"${uri}\"`);\n  }\n  const getter = exports.protocols[protocol];\n  return getter(url, opts);\n}\nexports.getUri = getUri;","map":{"version":3,"names":["debug_1","__importDefault","require","data_1","file_1","ftp_1","http_1","https_1","debug","default","exports","protocols","data","file","ftp","http","https","VALID_PROTOCOLS","Set","Object","keys","isValidProtocol","p","has","getUri","uri","opts","TypeError","url","URL","protocol","replace","getter"],"sources":["../src/index.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;AAAA,MAAAA,OAAA,GAAAC,eAAA,CAAAC,OAAA;AAGA;AACA,MAAAC,MAAA,GAAAD,OAAA;AACA,MAAAE,MAAA,GAAAF,OAAA;AACA,MAAAG,KAAA,GAAAH,OAAA;AACA,MAAAI,MAAA,GAAAJ,OAAA;AACA,MAAAK,OAAA,GAAAL,OAAA;AAEA,MAAMM,KAAK,GAAG,IAAAR,OAAA,CAAAS,OAAW,EAAC,SAAS,CAAC;AAOvBC,OAAA,CAAAC,SAAS,GAAG;EACxBC,IAAI,EAAJT,MAAA,CAAAS,IAAI;EACJC,IAAI,EAAJT,MAAA,CAAAS,IAAI;EACJC,GAAG,EAAHT,KAAA,CAAAS,GAAG;EACHC,IAAI,EAAJT,MAAA,CAAAS,IAAI;EACJC,KAAK,EAALT,OAAA,CAAAS;CACA;AAcD,MAAMC,eAAe,GAAG,IAAIC,GAAG,CAACC,MAAM,CAACC,IAAI,CAACV,OAAA,CAAAC,SAAS,CAAC,CAAC;AAEvD,SAAgBU,eAAeA,CAACC,CAAS;EACxC,OAAOL,eAAe,CAACM,GAAG,CAACD,CAAC,CAAC;AAC9B;AAFAZ,OAAA,CAAAW,eAAA,GAAAA,eAAA;AAIA;;;;;;;;;;;;;;;AAeO,eAAeG,MAAMA,CAC3BC,GAAc,EACdC,IAAwB;EAExBlB,KAAK,CAAC,YAAY,EAAEiB,GAAG,CAAC;EAExB,IAAI,CAACA,GAAG,EAAE;IACT,MAAM,IAAIE,SAAS,CAAC,kCAAkC,CAAC;;EAGxD,MAAMC,GAAG,GAAG,OAAOH,GAAG,KAAK,QAAQ,GAAG,IAAII,GAAG,CAACJ,GAAG,CAAC,GAAGA,GAAG;EAExD;EACA,MAAMK,QAAQ,GAAGF,GAAG,CAACE,QAAQ,CAACC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;EAC/C,IAAI,CAACV,eAAe,CAACS,QAAQ,CAAC,EAAE;IAC/B,MAAM,IAAIH,SAAS,CAClB,yBAAyBG,QAAQ,wBAAwBL,GAAG,GAAG,CAC/D;;EAGF,MAAMO,MAAM,GAAGtB,OAAA,CAAAC,SAAS,CAACmB,QAAQ,CAAC;EAClC,OAAOE,MAAM,CAACJ,GAAG,EAAEF,IAAa,CAAC;AAClC;AAtBAhB,OAAA,CAAAc,MAAA,GAAAA,MAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}