{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shouldInterruptAfterDeadline = exports.newAsyncContext = exports.newAsyncRuntime = exports.getQuickJSSync = exports.getQuickJS = exports.errors = exports.RELEASE_SYNC = exports.RELEASE_ASYNC = exports.DEBUG_SYNC = exports.DEBUG_ASYNC = exports.newQuickJSAsyncWASMModule = exports.newQuickJSWASMModule = void 0;\n// Build variants\nconst variants_1 = require(\"./variants\");\nObject.defineProperty(exports, \"newQuickJSWASMModule\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.newQuickJSWASMModule;\n  }\n});\nObject.defineProperty(exports, \"newQuickJSAsyncWASMModule\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.newQuickJSAsyncWASMModule;\n  }\n});\nObject.defineProperty(exports, \"DEBUG_ASYNC\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.DEBUG_ASYNC;\n  }\n});\nObject.defineProperty(exports, \"DEBUG_SYNC\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.DEBUG_SYNC;\n  }\n});\nObject.defineProperty(exports, \"RELEASE_ASYNC\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.RELEASE_ASYNC;\n  }\n});\nObject.defineProperty(exports, \"RELEASE_SYNC\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.RELEASE_SYNC;\n  }\n});\n// Export helpers\n__exportStar(require(\"./vm-interface\"), exports);\n__exportStar(require(\"./lifetime\"), exports);\n/** Collects the informative errors this library may throw. */\nexports.errors = __importStar(require(\"./errors\"));\n__exportStar(require(\"./deferred-promise\"), exports);\n__exportStar(require(\"./module-test\"), exports);\nlet singleton = undefined;\nlet singletonPromise = undefined;\n/**\n * Get a shared singleton {@link QuickJSWASMModule}. Use this to evaluate code\n * or create Javascript environments.\n *\n * This is the top-level entrypoint for the quickjs-emscripten library.\n *\n * If you need strictest possible isolation guarantees, you may create a\n * separate {@link QuickJSWASMModule} via {@link newQuickJSWASMModule}.\n *\n * To work with the asyncified version of this library, see these functions:\n *\n * - {@link newAsyncRuntime}.\n * - {@link newAsyncContext}.\n * - {@link newQuickJSAsyncWASMModule}.\n */\nasync function getQuickJS() {\n  singletonPromise ?? (singletonPromise = (0, variants_1.newQuickJSWASMModule)().then(instance => {\n    singleton = instance;\n    return instance;\n  }));\n  return await singletonPromise;\n}\nexports.getQuickJS = getQuickJS;\n/**\n * Provides synchronous access to the shared {@link QuickJSWASMModule} instance returned by {@link getQuickJS}, as long as\n * least once.\n * @throws If called before `getQuickJS` resolves.\n */\nfunction getQuickJSSync() {\n  if (!singleton) {\n    throw new Error(\"QuickJS not initialized. Await getQuickJS() at least once.\");\n  }\n  return singleton;\n}\nexports.getQuickJSSync = getQuickJSSync;\n/**\n * Create a new [[QuickJSAsyncRuntime]] in a separate WebAssembly module.\n *\n * Each runtime is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nasync function newAsyncRuntime(options) {\n  const module = await (0, variants_1.newQuickJSAsyncWASMModule)();\n  return module.newRuntime(options);\n}\nexports.newAsyncRuntime = newAsyncRuntime;\n/**\n * Create a new [[QuickJSAsyncContext]] (with an associated runtime) in an\n * separate WebAssembly module.\n *\n * Each context is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nasync function newAsyncContext(options) {\n  const module = await (0, variants_1.newQuickJSAsyncWASMModule)();\n  return module.newContext(options);\n}\nexports.newAsyncContext = newAsyncContext;\n/**\n * Returns an interrupt handler that interrupts Javascript execution after a deadline time.\n *\n * @param deadline - Interrupt execution if it's still running after this time.\n *   Number values are compared against `Date.now()`\n */\nfunction shouldInterruptAfterDeadline(deadline) {\n  const deadlineAsNumber = typeof deadline === \"number\" ? deadline : deadline.getTime();\n  return function () {\n    return Date.now() > deadlineAsNumber;\n  };\n}\nexports.shouldInterruptAfterDeadline = shouldInterruptAfterDeadline;","map":{"version":3,"names":["variants_1","require","Object","defineProperty","exports","enumerable","get","newQuickJSWASMModule","newQuickJSAsyncWASMModule","DEBUG_ASYNC","DEBUG_SYNC","RELEASE_ASYNC","RELEASE_SYNC","__exportStar","errors","__importStar","singleton","undefined","singletonPromise","getQuickJS","then","instance","getQuickJSSync","Error","newAsyncRuntime","options","module","newRuntime","newAsyncContext","newContext","shouldInterruptAfterDeadline","deadline","deadlineAsNumber","getTime","Date","now"],"sources":["../ts/index.ts"],"sourcesContent":["// Sync classes\nimport type { QuickJSWASMModule } from \"./module\"\nimport type { QuickJSRuntime, InterruptHandler } from \"./runtime\"\nimport type { QuickJSContext } from \"./context\"\nexport type { QuickJSWASMModule, QuickJSContext, QuickJSRuntime }\n\n// Async classes\nimport type { QuickJSAsyncWASMModule } from \"./module-asyncify\"\nimport type { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport type { QuickJSAsyncContext, AsyncFunctionImplementation } from \"./context-asyncify\"\nimport { AsyncRuntimeOptions, ContextOptions } from \"./types\"\nexport type {\n  QuickJSAsyncContext,\n  QuickJSAsyncRuntime,\n  QuickJSAsyncWASMModule,\n  AsyncFunctionImplementation,\n}\n\n// Build variants\nimport {\n  newQuickJSWASMModule,\n  newQuickJSAsyncWASMModule,\n  DEBUG_ASYNC,\n  DEBUG_SYNC,\n  RELEASE_ASYNC,\n  RELEASE_SYNC,\n  SyncBuildVariant,\n  AsyncBuildVariant,\n} from \"./variants\"\nexport {\n  newQuickJSWASMModule,\n  newQuickJSAsyncWASMModule,\n  DEBUG_ASYNC,\n  DEBUG_SYNC,\n  RELEASE_ASYNC,\n  RELEASE_SYNC,\n  SyncBuildVariant,\n  AsyncBuildVariant,\n}\n\n// Export helpers\nexport * from \"./vm-interface\"\nexport * from \"./lifetime\"\n/** Collects the informative errors this library may throw. */\nexport * as errors from \"./errors\"\nexport * from \"./deferred-promise\"\nexport * from \"./module-test\"\nexport type {\n  StaticJSValue,\n  JSValueConst,\n  JSValue,\n  QuickJSHandle,\n  ContextOptions,\n  ContextEvalOptions,\n  RuntimeOptions,\n  AsyncRuntimeOptions,\n  RuntimeOptionsBase,\n  JSModuleLoader,\n  JSModuleLoadResult,\n  JSModuleLoaderAsync,\n  JSModuleLoadSuccess,\n  JSModuleLoadFailure,\n  JSModuleNormalizer,\n  JSModuleNormalizerAsync,\n  JSModuleNormalizeResult,\n  JSModuleNormalizeFailure,\n  JSModuleNormalizeSuccess,\n} from \"./types\"\nexport type { ModuleEvalOptions } from \"./module\"\nexport type { InterruptHandler, ExecutePendingJobsResult } from \"./runtime\"\nexport type { QuickJSPropertyKey } from \"./context\"\n\nlet singleton: QuickJSWASMModule | undefined = undefined\nlet singletonPromise: Promise<QuickJSWASMModule> | undefined = undefined\n\n/**\n * Get a shared singleton {@link QuickJSWASMModule}. Use this to evaluate code\n * or create Javascript environments.\n *\n * This is the top-level entrypoint for the quickjs-emscripten library.\n *\n * If you need strictest possible isolation guarantees, you may create a\n * separate {@link QuickJSWASMModule} via {@link newQuickJSWASMModule}.\n *\n * To work with the asyncified version of this library, see these functions:\n *\n * - {@link newAsyncRuntime}.\n * - {@link newAsyncContext}.\n * - {@link newQuickJSAsyncWASMModule}.\n */\nexport async function getQuickJS(): Promise<QuickJSWASMModule> {\n  singletonPromise ??= newQuickJSWASMModule().then((instance) => {\n    singleton = instance\n    return instance\n  })\n  return await singletonPromise\n}\n\n/**\n * Provides synchronous access to the shared {@link QuickJSWASMModule} instance returned by {@link getQuickJS}, as long as\n * least once.\n * @throws If called before `getQuickJS` resolves.\n */\nexport function getQuickJSSync(): QuickJSWASMModule {\n  if (!singleton) {\n    throw new Error(\"QuickJS not initialized. Await getQuickJS() at least once.\")\n  }\n  return singleton\n}\n\n/**\n * Create a new [[QuickJSAsyncRuntime]] in a separate WebAssembly module.\n *\n * Each runtime is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newAsyncRuntime(options?: AsyncRuntimeOptions): Promise<QuickJSAsyncRuntime> {\n  const module = await newQuickJSAsyncWASMModule()\n  return module.newRuntime(options)\n}\n\n/**\n * Create a new [[QuickJSAsyncContext]] (with an associated runtime) in an\n * separate WebAssembly module.\n *\n * Each context is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newAsyncContext(options?: ContextOptions): Promise<QuickJSAsyncContext> {\n  const module = await newQuickJSAsyncWASMModule()\n  return module.newContext(options)\n}\n\n/**\n * Returns an interrupt handler that interrupts Javascript execution after a deadline time.\n *\n * @param deadline - Interrupt execution if it's still running after this time.\n *   Number values are compared against `Date.now()`\n */\nexport function shouldInterruptAfterDeadline(deadline: Date | number): InterruptHandler {\n  const deadlineAsNumber = typeof deadline === \"number\" ? deadline : deadline.getTime()\n\n  return function () {\n    return Date.now() > deadlineAsNumber\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AACA,MAAAA,UAAA,GAAAC,OAAA;AAWEC,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAVAN,UAAA,CAAAO,oBAAoB;EAAA;AAAA;AAWpBL,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAVAN,UAAA,CAAAQ,yBAAyB;EAAA;AAAA;AAWzBN,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAVAN,UAAA,CAAAS,WAAW;EAAA;AAAA;AAWXP,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAVAN,UAAA,CAAAU,UAAU;EAAA;AAAA;AAWVR,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAVAN,UAAA,CAAAW,aAAa;EAAA;AAAA;AAWbT,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAVAN,UAAA,CAAAY,YAAY;EAAA;AAAA;AAed;AACAC,YAAA,CAAAZ,OAAA,oBAAAG,OAAA;AACAS,YAAA,CAAAZ,OAAA,gBAAAG,OAAA;AACA;AACAA,OAAA,CAAAU,MAAA,GAAAC,YAAA,CAAAd,OAAA;AACAY,YAAA,CAAAZ,OAAA,wBAAAG,OAAA;AACAS,YAAA,CAAAZ,OAAA,mBAAAG,OAAA;AA0BA,IAAIY,SAAS,GAAkCC,SAAS;AACxD,IAAIC,gBAAgB,GAA2CD,SAAS;AAExE;;;;;;;;;;;;;;;AAeO,eAAeE,UAAUA,CAAA;EAC9BD,gBAAgB,KAAhBA,gBAAgB,GAAK,IAAAlB,UAAA,CAAAO,oBAAoB,GAAE,CAACa,IAAI,CAAEC,QAAQ,IAAI;IAC5DL,SAAS,GAAGK,QAAQ;IACpB,OAAOA,QAAQ;EACjB,CAAC,CAAC;EACF,OAAO,MAAMH,gBAAgB;AAC/B;AANAd,OAAA,CAAAe,UAAA,GAAAA,UAAA;AAQA;;;;;AAKA,SAAgBG,cAAcA,CAAA;EAC5B,IAAI,CAACN,SAAS,EAAE;IACd,MAAM,IAAIO,KAAK,CAAC,4DAA4D,CAAC;;EAE/E,OAAOP,SAAS;AAClB;AALAZ,OAAA,CAAAkB,cAAA,GAAAA,cAAA;AAOA;;;;;;;;;;;AAWO,eAAeE,eAAeA,CAACC,OAA6B;EACjE,MAAMC,MAAM,GAAG,MAAM,IAAA1B,UAAA,CAAAQ,yBAAyB,GAAE;EAChD,OAAOkB,MAAM,CAACC,UAAU,CAACF,OAAO,CAAC;AACnC;AAHArB,OAAA,CAAAoB,eAAA,GAAAA,eAAA;AAKA;;;;;;;;;;;;AAYO,eAAeI,eAAeA,CAACH,OAAwB;EAC5D,MAAMC,MAAM,GAAG,MAAM,IAAA1B,UAAA,CAAAQ,yBAAyB,GAAE;EAChD,OAAOkB,MAAM,CAACG,UAAU,CAACJ,OAAO,CAAC;AACnC;AAHArB,OAAA,CAAAwB,eAAA,GAAAA,eAAA;AAKA;;;;;;AAMA,SAAgBE,4BAA4BA,CAACC,QAAuB;EAClE,MAAMC,gBAAgB,GAAG,OAAOD,QAAQ,KAAK,QAAQ,GAAGA,QAAQ,GAAGA,QAAQ,CAACE,OAAO,EAAE;EAErF,OAAO;IACL,OAAOC,IAAI,CAACC,GAAG,EAAE,GAAGH,gBAAgB;EACtC,CAAC;AACH;AANA5B,OAAA,CAAA0B,4BAAA,GAAAA,4BAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}