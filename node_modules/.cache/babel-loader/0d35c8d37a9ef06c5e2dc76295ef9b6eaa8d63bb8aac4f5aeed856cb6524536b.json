{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Scope = exports.WeakLifetime = exports.StaticLifetime = exports.Lifetime = void 0;\nconst asyncify_helpers_1 = require(\"./asyncify-helpers\");\nconst debug_1 = require(\"./debug\");\nconst errors_1 = require(\"./errors\");\n/**\n * A lifetime prevents access to a value after the lifetime has been\n * [[dispose]]ed.\n *\n * Typically, quickjs-emscripten uses Lifetimes to protect C memory pointers.\n */\nclass Lifetime {\n  /**\n   * When the Lifetime is disposed, it will call `disposer(_value)`. Use the\n   * disposer function to implement whatever cleanup needs to happen at the end\n   * of `value`'s lifetime.\n   *\n   * `_owner` is not used or controlled by the lifetime. It's just metadata for\n   * the creator.\n   */\n  constructor(_value, copier, disposer, _owner) {\n    this._value = _value;\n    this.copier = copier;\n    this.disposer = disposer;\n    this._owner = _owner;\n    this._alive = true;\n    this._constructorStack = debug_1.QTS_DEBUG ? new Error(\"Lifetime constructed\").stack : undefined;\n  }\n  get alive() {\n    return this._alive;\n  }\n  /**\n   * The value this Lifetime protects. You must never retain the value - it\n   * may become invalid, leading to memory errors.\n   *\n   * @throws If the lifetime has been [[dispose]]d already.\n   */\n  get value() {\n    this.assertAlive();\n    return this._value;\n  }\n  get owner() {\n    return this._owner;\n  }\n  get dupable() {\n    return !!this.copier;\n  }\n  /**\n   * Create a new handle pointing to the same [[value]].\n   */\n  dup() {\n    this.assertAlive();\n    if (!this.copier) {\n      throw new Error(\"Non-dupable lifetime\");\n    }\n    return new Lifetime(this.copier(this._value), this.copier, this.disposer, this._owner);\n  }\n  consume(map) {\n    this.assertAlive();\n    const result = map(this);\n    this.dispose();\n    return result;\n  }\n  /**\n   * Dispose of [[value]] and perform cleanup.\n   */\n  dispose() {\n    this.assertAlive();\n    if (this.disposer) {\n      this.disposer(this._value);\n    }\n    this._alive = false;\n  }\n  assertAlive() {\n    if (!this.alive) {\n      if (this._constructorStack) {\n        throw new errors_1.QuickJSUseAfterFree(`Lifetime not alive\\n${this._constructorStack}\\nLifetime used`);\n      }\n      throw new errors_1.QuickJSUseAfterFree(\"Lifetime not alive\");\n    }\n  }\n}\nexports.Lifetime = Lifetime;\n/**\n * A Lifetime that lives forever. Used for constants.\n */\nclass StaticLifetime extends Lifetime {\n  constructor(value, owner) {\n    super(value, undefined, undefined, owner);\n  }\n  // Static lifetime doesn't need a copier to be copiable\n  get dupable() {\n    return true;\n  }\n  // Copy returns the same instance.\n  dup() {\n    return this;\n  }\n  // Dispose does nothing.\n  dispose() {}\n}\nexports.StaticLifetime = StaticLifetime;\n/**\n * A Lifetime that does not own its `value`. A WeakLifetime never calls its\n * `disposer` function, but can be `dup`ed to produce regular lifetimes that\n * do.\n *\n * Used for function arguments.\n */\nclass WeakLifetime extends Lifetime {\n  constructor(value, copier, disposer, owner) {\n    // We don't care if the disposer doesn't support freeing T\n    super(value, copier, disposer, owner);\n  }\n  dispose() {\n    this._alive = false;\n  }\n}\nexports.WeakLifetime = WeakLifetime;\nfunction scopeFinally(scope, blockError) {\n  // console.log('scopeFinally', scope, blockError)\n  let disposeError;\n  try {\n    scope.dispose();\n  } catch (error) {\n    disposeError = error;\n  }\n  if (blockError && disposeError) {\n    Object.assign(blockError, {\n      message: `${blockError.message}\\n Then, failed to dispose scope: ${disposeError.message}`,\n      disposeError\n    });\n    throw blockError;\n  }\n  if (blockError || disposeError) {\n    throw blockError || disposeError;\n  }\n}\n/**\n * Scope helps reduce the burden of manually tracking and disposing of\n * Lifetimes. See [[withScope]]. and [[withScopeAsync]].\n */\nclass Scope {\n  constructor() {\n    this._disposables = new Lifetime(new Set());\n  }\n  /**\n   * Run `block` with a new Scope instance that will be disposed after the block returns.\n   * Inside `block`, call `scope.manage` on each lifetime you create to have the lifetime\n   * automatically disposed after the block returns.\n   *\n   * @warning Do not use with async functions. Instead, use [[withScopeAsync]].\n   */\n  static withScope(block) {\n    const scope = new Scope();\n    let blockError;\n    try {\n      return block(scope);\n    } catch (error) {\n      blockError = error;\n      throw error;\n    } finally {\n      scopeFinally(scope, blockError);\n    }\n  }\n  static withScopeMaybeAsync(_this, block) {\n    return (0, asyncify_helpers_1.maybeAsync)(undefined, function* (awaited) {\n      const scope = new Scope();\n      let blockError;\n      try {\n        return yield* awaited.of(block.call(_this, awaited, scope));\n      } catch (error) {\n        blockError = error;\n        throw error;\n      } finally {\n        scopeFinally(scope, blockError);\n      }\n    });\n  }\n  /**\n   * Run `block` with a new Scope instance that will be disposed after the\n   * block's returned promise settles. Inside `block`, call `scope.manage` on each\n   * lifetime you create to have the lifetime automatically disposed after the\n   * block returns.\n   */\n  static async withScopeAsync(block) {\n    const scope = new Scope();\n    let blockError;\n    try {\n      return await block(scope);\n    } catch (error) {\n      blockError = error;\n      throw error;\n    } finally {\n      scopeFinally(scope, blockError);\n    }\n  }\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage(lifetime) {\n    this._disposables.value.add(lifetime);\n    return lifetime;\n  }\n  get alive() {\n    return this._disposables.alive;\n  }\n  dispose() {\n    const lifetimes = Array.from(this._disposables.value.values()).reverse();\n    for (const lifetime of lifetimes) {\n      if (lifetime.alive) {\n        lifetime.dispose();\n      }\n    }\n    this._disposables.dispose();\n  }\n}\nexports.Scope = Scope;","map":{"version":3,"names":["asyncify_helpers_1","require","debug_1","errors_1","Lifetime","constructor","_value","copier","disposer","_owner","_alive","_constructorStack","QTS_DEBUG","Error","stack","undefined","alive","value","assertAlive","owner","dupable","dup","consume","map","result","dispose","QuickJSUseAfterFree","exports","StaticLifetime","WeakLifetime","scopeFinally","scope","blockError","disposeError","error","Object","assign","message","Scope","_disposables","Set","withScope","block","withScopeMaybeAsync","_this","maybeAsync","awaited","of","call","withScopeAsync","manage","lifetime","add","lifetimes","Array","from","values","reverse"],"sources":["../ts/lifetime.ts"],"sourcesContent":["import { maybeAsync, MaybeAsyncBlock } from \"./asyncify-helpers\"\nimport { QTS_DEBUG } from \"./debug\"\nimport { QuickJSUseAfterFree } from \"./errors\"\nimport type { QuickJSHandle } from \"./types\"\n\n/**\n * An object that can be disposed.\n * [[Lifetime]] is the canonical implementation of Disposable.\n * Use [[Scope]] to manage cleaning up multiple disposables.\n */\nexport interface Disposable {\n  /**\n   * Dispose of the underlying resources used by this object.\n   */\n  dispose(): void\n\n  /**\n   * @returns true if the object is alive\n   * @returns false after the object has been [[dispose]]d\n   */\n  alive: boolean\n}\n\n/**\n * A lifetime prevents access to a value after the lifetime has been\n * [[dispose]]ed.\n *\n * Typically, quickjs-emscripten uses Lifetimes to protect C memory pointers.\n */\nexport class Lifetime<T, TCopy = never, Owner = never> implements Disposable {\n  protected _alive: boolean = true\n  protected _constructorStack = QTS_DEBUG ? new Error(\"Lifetime constructed\").stack : undefined\n\n  /**\n   * When the Lifetime is disposed, it will call `disposer(_value)`. Use the\n   * disposer function to implement whatever cleanup needs to happen at the end\n   * of `value`'s lifetime.\n   *\n   * `_owner` is not used or controlled by the lifetime. It's just metadata for\n   * the creator.\n   */\n  constructor(\n    protected readonly _value: T,\n    protected readonly copier?: (value: T | TCopy) => TCopy,\n    protected readonly disposer?: (value: T | TCopy) => void,\n    protected readonly _owner?: Owner\n  ) {}\n\n  get alive() {\n    return this._alive\n  }\n\n  /**\n   * The value this Lifetime protects. You must never retain the value - it\n   * may become invalid, leading to memory errors.\n   *\n   * @throws If the lifetime has been [[dispose]]d already.\n   */\n  get value() {\n    this.assertAlive()\n    return this._value\n  }\n\n  get owner() {\n    return this._owner\n  }\n\n  get dupable() {\n    return !!this.copier\n  }\n\n  /**\n   * Create a new handle pointing to the same [[value]].\n   */\n  dup() {\n    this.assertAlive()\n    if (!this.copier) {\n      throw new Error(\"Non-dupable lifetime\")\n    }\n    return new Lifetime<TCopy, TCopy, Owner>(\n      this.copier(this._value),\n      this.copier,\n      this.disposer,\n      this._owner\n    )\n  }\n\n  /**\n   * Call `map` with this lifetime, then dispose the lifetime.\n   * @return the result of `map(this)`.\n   */\n  consume<O>(map: (lifetime: this) => O): O\n  // A specific type definition is needed for our common use-case\n  // https://github.com/microsoft/TypeScript/issues/30271\n  consume<O>(map: (lifetime: QuickJSHandle) => O): O\n  consume<O>(map: (lifetime: any) => O): O {\n    this.assertAlive()\n    const result = map(this)\n    this.dispose()\n    return result\n  }\n\n  /**\n   * Dispose of [[value]] and perform cleanup.\n   */\n  dispose() {\n    this.assertAlive()\n    if (this.disposer) {\n      this.disposer(this._value)\n    }\n    this._alive = false\n  }\n\n  private assertAlive() {\n    if (!this.alive) {\n      if (this._constructorStack) {\n        throw new QuickJSUseAfterFree(\n          `Lifetime not alive\\n${this._constructorStack}\\nLifetime used`\n        )\n      }\n      throw new QuickJSUseAfterFree(\"Lifetime not alive\")\n    }\n  }\n}\n\n/**\n * A Lifetime that lives forever. Used for constants.\n */\nexport class StaticLifetime<T, Owner = never> extends Lifetime<T, T, Owner> {\n  constructor(value: T, owner?: Owner) {\n    super(value, undefined, undefined, owner)\n  }\n\n  // Static lifetime doesn't need a copier to be copiable\n  get dupable() {\n    return true\n  }\n\n  // Copy returns the same instance.\n  dup() {\n    return this\n  }\n\n  // Dispose does nothing.\n  dispose() {}\n}\n\n/**\n * A Lifetime that does not own its `value`. A WeakLifetime never calls its\n * `disposer` function, but can be `dup`ed to produce regular lifetimes that\n * do.\n *\n * Used for function arguments.\n */\nexport class WeakLifetime<T, TCopy = never, Owner = never> extends Lifetime<T, TCopy, Owner> {\n  constructor(\n    value: T,\n    copier?: (value: T | TCopy) => TCopy,\n    disposer?: (value: TCopy) => void,\n    owner?: Owner\n  ) {\n    // We don't care if the disposer doesn't support freeing T\n    super(value, copier, disposer as (value: T | TCopy) => void, owner)\n  }\n\n  dispose() {\n    this._alive = false\n  }\n}\n\nfunction scopeFinally(scope: Scope, blockError: Error | undefined) {\n  // console.log('scopeFinally', scope, blockError)\n  let disposeError: Error | undefined\n  try {\n    scope.dispose()\n  } catch (error) {\n    disposeError = error as any\n  }\n\n  if (blockError && disposeError) {\n    Object.assign(blockError, {\n      message: `${blockError.message}\\n Then, failed to dispose scope: ${disposeError.message}`,\n      disposeError,\n    })\n    throw blockError\n  }\n\n  if (blockError || disposeError) {\n    throw blockError || disposeError\n  }\n}\n\n/**\n * Scope helps reduce the burden of manually tracking and disposing of\n * Lifetimes. See [[withScope]]. and [[withScopeAsync]].\n */\nexport class Scope implements Disposable {\n  /**\n   * Run `block` with a new Scope instance that will be disposed after the block returns.\n   * Inside `block`, call `scope.manage` on each lifetime you create to have the lifetime\n   * automatically disposed after the block returns.\n   *\n   * @warning Do not use with async functions. Instead, use [[withScopeAsync]].\n   */\n  static withScope<R>(block: (scope: Scope) => R): R {\n    const scope = new Scope()\n    let blockError: Error | undefined\n    try {\n      return block(scope)\n    } catch (error) {\n      blockError = error as any\n      throw error\n    } finally {\n      scopeFinally(scope, blockError)\n    }\n  }\n\n  static withScopeMaybeAsync<Return, This, Yielded>(\n    _this: This,\n    block: MaybeAsyncBlock<Return, This, Yielded, [Scope]>\n  ): Return | Promise<Return> {\n    return maybeAsync(undefined, function* (awaited) {\n      const scope = new Scope()\n      let blockError: Error | undefined\n      try {\n        return yield* awaited.of(block.call(_this, awaited, scope))\n      } catch (error) {\n        blockError = error as any\n        throw error\n      } finally {\n        scopeFinally(scope, blockError)\n      }\n    })\n  }\n\n  /**\n   * Run `block` with a new Scope instance that will be disposed after the\n   * block's returned promise settles. Inside `block`, call `scope.manage` on each\n   * lifetime you create to have the lifetime automatically disposed after the\n   * block returns.\n   */\n  static async withScopeAsync<R>(block: (scope: Scope) => Promise<R>): Promise<R> {\n    const scope = new Scope()\n    let blockError: Error | undefined\n    try {\n      return await block(scope)\n    } catch (error) {\n      blockError = error as any\n      throw error\n    } finally {\n      scopeFinally(scope, blockError)\n    }\n  }\n\n  private _disposables: Lifetime<Set<Disposable>> = new Lifetime(new Set())\n\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage<T extends Disposable>(lifetime: T): T {\n    this._disposables.value.add(lifetime)\n    return lifetime\n  }\n\n  get alive() {\n    return this._disposables.alive\n  }\n\n  dispose() {\n    const lifetimes = Array.from(this._disposables.value.values()).reverse()\n    for (const lifetime of lifetimes) {\n      if (lifetime.alive) {\n        lifetime.dispose()\n      }\n    }\n    this._disposables.dispose()\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}