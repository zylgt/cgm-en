{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TestQuickJSWASMModule = void 0;\nconst errors_1 = require(\"./errors\");\nconst lifetime_1 = require(\"./lifetime\");\n/**\n * A test wrapper of [[QuickJSWASMModule]] that keeps a reference to each\n * context or runtime created.\n *\n * Call [[disposeAll]] to reset these sets and calls `dispose` on any left alive\n * (which may throw an error).\n *\n * Call [[assertNoMemoryAllocated]] at the end of a test, when you expect that you've\n * freed all the memory you've ever allocated.\n */\nclass TestQuickJSWASMModule {\n  constructor(parent) {\n    this.parent = parent;\n    this.contexts = new Set();\n    this.runtimes = new Set();\n  }\n  newRuntime(options) {\n    const runtime = this.parent.newRuntime({\n      ...options,\n      ownedLifetimes: [new lifetime_1.Lifetime(undefined, undefined, () => this.runtimes.delete(runtime)), ...(options?.ownedLifetimes ?? [])]\n    });\n    this.runtimes.add(runtime);\n    return runtime;\n  }\n  newContext(options) {\n    const context = this.parent.newContext({\n      ...options,\n      ownedLifetimes: [new lifetime_1.Lifetime(undefined, undefined, () => this.contexts.delete(context)), ...(options?.ownedLifetimes ?? [])]\n    });\n    this.contexts.add(context);\n    return context;\n  }\n  evalCode(code, options) {\n    return this.parent.evalCode(code, options);\n  }\n  disposeAll() {\n    const allDisposables = [...this.contexts, ...this.runtimes];\n    this.runtimes.clear();\n    this.contexts.clear();\n    allDisposables.forEach(d => {\n      if (d.alive) {\n        d.dispose();\n      }\n    });\n  }\n  assertNoMemoryAllocated() {\n    const leaksDetected = this.getFFI().QTS_RecoverableLeakCheck();\n    if (leaksDetected) {\n      // Note: this is currently only available when building from source\n      // with debug builds.\n      throw new errors_1.QuickJSMemoryLeakDetected(\"Leak sanitizer detected un-freed memory\");\n    }\n    if (this.contexts.size > 0) {\n      throw new errors_1.QuickJSMemoryLeakDetected(`${this.contexts.size} contexts leaked`);\n    }\n    if (this.runtimes.size > 0) {\n      throw new errors_1.QuickJSMemoryLeakDetected(`${this.runtimes.size} runtimes leaked`);\n    }\n  }\n  /** @private */\n  getFFI() {\n    return this.parent.getFFI();\n  }\n}\nexports.TestQuickJSWASMModule = TestQuickJSWASMModule;","map":{"version":3,"names":["errors_1","require","lifetime_1","TestQuickJSWASMModule","constructor","parent","contexts","Set","runtimes","newRuntime","options","runtime","ownedLifetimes","Lifetime","undefined","delete","add","newContext","context","evalCode","code","disposeAll","allDisposables","clear","forEach","d","alive","dispose","assertNoMemoryAllocated","leaksDetected","getFFI","QTS_RecoverableLeakCheck","QuickJSMemoryLeakDetected","size","exports"],"sources":["../ts/module-test.ts"],"sourcesContent":["import type { QuickJSContext } from \"./context\"\nimport type { ModuleEvalOptions, QuickJSWASMModule } from \"./module\"\nimport type { QuickJSRuntime } from \"./runtime\"\nimport type { ContextOptions, RuntimeOptions } from \"./types\"\nimport { QuickJSMemoryLeakDetected } from \"./errors\"\nimport { Lifetime } from \"./lifetime\"\n\n/**\n * A test wrapper of [[QuickJSWASMModule]] that keeps a reference to each\n * context or runtime created.\n *\n * Call [[disposeAll]] to reset these sets and calls `dispose` on any left alive\n * (which may throw an error).\n *\n * Call [[assertNoMemoryAllocated]] at the end of a test, when you expect that you've\n * freed all the memory you've ever allocated.\n */\nexport class TestQuickJSWASMModule implements Pick<QuickJSWASMModule, keyof QuickJSWASMModule> {\n  contexts = new Set<QuickJSContext>()\n  runtimes = new Set<QuickJSRuntime>()\n  constructor(private parent: QuickJSWASMModule) {}\n\n  newRuntime(options?: RuntimeOptions): QuickJSRuntime {\n    const runtime = this.parent.newRuntime({\n      ...options,\n      ownedLifetimes: [\n        new Lifetime(undefined, undefined, () => this.runtimes.delete(runtime)),\n        ...(options?.ownedLifetimes ?? []),\n      ],\n    })\n    this.runtimes.add(runtime)\n    return runtime\n  }\n\n  newContext(options?: ContextOptions): QuickJSContext {\n    const context = this.parent.newContext({\n      ...options,\n      ownedLifetimes: [\n        new Lifetime(undefined, undefined, () => this.contexts.delete(context)),\n        ...(options?.ownedLifetimes ?? []),\n      ],\n    })\n    this.contexts.add(context)\n    return context\n  }\n\n  evalCode(code: string, options?: ModuleEvalOptions): unknown {\n    return this.parent.evalCode(code, options)\n  }\n\n  disposeAll() {\n    const allDisposables = [...this.contexts, ...this.runtimes]\n    this.runtimes.clear()\n    this.contexts.clear()\n    allDisposables.forEach((d) => {\n      if (d.alive) {\n        d.dispose()\n      }\n    })\n  }\n\n  assertNoMemoryAllocated() {\n    const leaksDetected = this.getFFI().QTS_RecoverableLeakCheck()\n    if (leaksDetected) {\n      // Note: this is currently only available when building from source\n      // with debug builds.\n      throw new QuickJSMemoryLeakDetected(\"Leak sanitizer detected un-freed memory\")\n    }\n\n    if (this.contexts.size > 0) {\n      throw new QuickJSMemoryLeakDetected(`${this.contexts.size} contexts leaked`)\n    }\n\n    if (this.runtimes.size > 0) {\n      throw new QuickJSMemoryLeakDetected(`${this.runtimes.size} runtimes leaked`)\n    }\n  }\n\n  /** @private */\n  getFFI() {\n    return this.parent.getFFI()\n  }\n}\n"],"mappings":";;;;;;AAIA,MAAAA,QAAA,GAAAC,OAAA;AACA,MAAAC,UAAA,GAAAD,OAAA;AAEA;;;;;;;;;;AAUA,MAAaE,qBAAqB;EAGhCC,YAAoBC,MAAyB;IAAzB,KAAAA,MAAM,GAANA,MAAM;IAF1B,KAAAC,QAAQ,GAAG,IAAIC,GAAG,EAAkB;IACpC,KAAAC,QAAQ,GAAG,IAAID,GAAG,EAAkB;EACY;EAEhDE,UAAUA,CAACC,OAAwB;IACjC,MAAMC,OAAO,GAAG,IAAI,CAACN,MAAM,CAACI,UAAU,CAAC;MACrC,GAAGC,OAAO;MACVE,cAAc,EAAE,CACd,IAAIV,UAAA,CAAAW,QAAQ,CAACC,SAAS,EAAEA,SAAS,EAAE,MAAM,IAAI,CAACN,QAAQ,CAACO,MAAM,CAACJ,OAAO,CAAC,CAAC,EACvE,IAAID,OAAO,EAAEE,cAAc,IAAI,EAAE,CAAC;KAErC,CAAC;IACF,IAAI,CAACJ,QAAQ,CAACQ,GAAG,CAACL,OAAO,CAAC;IAC1B,OAAOA,OAAO;EAChB;EAEAM,UAAUA,CAACP,OAAwB;IACjC,MAAMQ,OAAO,GAAG,IAAI,CAACb,MAAM,CAACY,UAAU,CAAC;MACrC,GAAGP,OAAO;MACVE,cAAc,EAAE,CACd,IAAIV,UAAA,CAAAW,QAAQ,CAACC,SAAS,EAAEA,SAAS,EAAE,MAAM,IAAI,CAACR,QAAQ,CAACS,MAAM,CAACG,OAAO,CAAC,CAAC,EACvE,IAAIR,OAAO,EAAEE,cAAc,IAAI,EAAE,CAAC;KAErC,CAAC;IACF,IAAI,CAACN,QAAQ,CAACU,GAAG,CAACE,OAAO,CAAC;IAC1B,OAAOA,OAAO;EAChB;EAEAC,QAAQA,CAACC,IAAY,EAAEV,OAA2B;IAChD,OAAO,IAAI,CAACL,MAAM,CAACc,QAAQ,CAACC,IAAI,EAAEV,OAAO,CAAC;EAC5C;EAEAW,UAAUA,CAAA;IACR,MAAMC,cAAc,GAAG,CAAC,GAAG,IAAI,CAAChB,QAAQ,EAAE,GAAG,IAAI,CAACE,QAAQ,CAAC;IAC3D,IAAI,CAACA,QAAQ,CAACe,KAAK,EAAE;IACrB,IAAI,CAACjB,QAAQ,CAACiB,KAAK,EAAE;IACrBD,cAAc,CAACE,OAAO,CAAEC,CAAC,IAAI;MAC3B,IAAIA,CAAC,CAACC,KAAK,EAAE;QACXD,CAAC,CAACE,OAAO,EAAE;;IAEf,CAAC,CAAC;EACJ;EAEAC,uBAAuBA,CAAA;IACrB,MAAMC,aAAa,GAAG,IAAI,CAACC,MAAM,EAAE,CAACC,wBAAwB,EAAE;IAC9D,IAAIF,aAAa,EAAE;MACjB;MACA;MACA,MAAM,IAAI7B,QAAA,CAAAgC,yBAAyB,CAAC,yCAAyC,CAAC;;IAGhF,IAAI,IAAI,CAAC1B,QAAQ,CAAC2B,IAAI,GAAG,CAAC,EAAE;MAC1B,MAAM,IAAIjC,QAAA,CAAAgC,yBAAyB,CAAC,GAAG,IAAI,CAAC1B,QAAQ,CAAC2B,IAAI,kBAAkB,CAAC;;IAG9E,IAAI,IAAI,CAACzB,QAAQ,CAACyB,IAAI,GAAG,CAAC,EAAE;MAC1B,MAAM,IAAIjC,QAAA,CAAAgC,yBAAyB,CAAC,GAAG,IAAI,CAACxB,QAAQ,CAACyB,IAAI,kBAAkB,CAAC;;EAEhF;EAEA;EACAH,MAAMA,CAAA;IACJ,OAAO,IAAI,CAACzB,MAAM,CAACyB,MAAM,EAAE;EAC7B;;AAhEFI,OAAA,CAAA/B,qBAAA,GAAAA,qBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}