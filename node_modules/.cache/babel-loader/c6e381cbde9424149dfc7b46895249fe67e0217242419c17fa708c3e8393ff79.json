{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuickJSAsyncContext = void 0;\nconst context_1 = require(\"./context\");\nconst debug_1 = require(\"./debug\");\nconst types_1 = require(\"./types\");\n/**\n * Asyncified version of [[QuickJSContext]].\n *\n * *Asyncify* allows normally synchronous code to wait for asynchronous Promises\n * or callbacks. The asyncified version of QuickJSContext can wait for async\n * host functions as though they were synchronous.\n */\nclass QuickJSAsyncContext extends context_1.QuickJSContext {\n  /**\n   * Asyncified version of [[evalCode]].\n   */\n  async evalCodeAsync(code, filename = \"eval.js\", /** See [[EvalFlags]] for number semantics */\n  options) {\n    const detectModule = options === undefined ? 1 : 0;\n    const flags = (0, types_1.evalOptionsToFlags)(options);\n    let resultPtr = 0;\n    try {\n      resultPtr = await this.memory.newHeapCharPointer(code).consume(charHandle => this.ffi.QTS_Eval_MaybeAsync(this.ctx.value, charHandle.value, filename, detectModule, flags));\n    } catch (error) {\n      (0, debug_1.debugLog)(\"QTS_Eval_MaybeAsync threw\", error);\n      throw error;\n    }\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);\n      return {\n        error: this.memory.heapValueHandle(errorPtr)\n      };\n    }\n    return {\n      value: this.memory.heapValueHandle(resultPtr)\n    };\n  }\n  /**\n   * Similar to [[newFunction]].\n   * Convert an async host Javascript function into a synchronous QuickJS function value.\n   *\n   * Whenever QuickJS calls this function, the VM's stack will be unwound while\n   * waiting the async function to complete, and then restored when the returned\n   * promise resolves.\n   *\n   * Asyncified functions must never call other asyncified functions or\n   * `import`, even indirectly, because the stack cannot be unwound twice.\n   *\n   * See [Emscripten's docs on Asyncify](https://emscripten.org/docs/porting/asyncify.html).\n   */\n  newAsyncifiedFunction(name, fn) {\n    return this.newFunction(name, fn);\n  }\n}\nexports.QuickJSAsyncContext = QuickJSAsyncContext;","map":{"version":3,"names":["context_1","require","debug_1","types_1","QuickJSAsyncContext","QuickJSContext","evalCodeAsync","code","filename","options","detectModule","undefined","flags","evalOptionsToFlags","resultPtr","memory","newHeapCharPointer","consume","charHandle","ffi","QTS_Eval_MaybeAsync","ctx","value","error","debugLog","errorPtr","QTS_ResolveException","QTS_FreeValuePointer","heapValueHandle","newAsyncifiedFunction","name","fn","newFunction","exports"],"sources":["../ts/context-asyncify.ts"],"sourcesContent":["import { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport { QuickJSAsyncEmscriptenModule } from \"./emscripten-types\"\nimport { QuickJSAsyncFFI } from \"./variants\"\nimport { EvalDetectModule, EvalFlags, JSRuntimePointer, JSValuePointer } from \"./types-ffi\"\nimport { Lifetime } from \"./lifetime\"\nimport { QuickJSModuleCallbacks } from \"./module\"\nimport { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport { ContextEvalOptions, evalOptionsToFlags, QuickJSHandle } from \"./types\"\nimport { VmCallResult } from \"./vm-interface\"\n\nexport type AsyncFunctionImplementation = (\n  this: QuickJSHandle,\n  ...args: QuickJSHandle[]\n) => Promise<QuickJSHandle | VmCallResult<QuickJSHandle> | void>\n\n/**\n * Asyncified version of [[QuickJSContext]].\n *\n * *Asyncify* allows normally synchronous code to wait for asynchronous Promises\n * or callbacks. The asyncified version of QuickJSContext can wait for async\n * host functions as though they were synchronous.\n */\nexport class QuickJSAsyncContext extends QuickJSContext {\n  public declare runtime: QuickJSAsyncRuntime\n  /** @private */\n  protected declare module: QuickJSAsyncEmscriptenModule\n  /** @private */\n  protected declare ffi: QuickJSAsyncFFI\n  /** @private */\n  protected declare rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected declare callbacks: QuickJSModuleCallbacks\n\n  /**\n   * Asyncified version of [[evalCode]].\n   */\n  async evalCodeAsync(\n    code: string,\n    filename: string = \"eval.js\",\n    /** See [[EvalFlags]] for number semantics */\n    options?: number | ContextEvalOptions\n  ): Promise<VmCallResult<QuickJSHandle>> {\n    const detectModule = (options === undefined ? 1 : 0) as EvalDetectModule\n    const flags = evalOptionsToFlags(options) as EvalFlags\n    let resultPtr = 0 as JSValuePointer\n    try {\n      resultPtr = await this.memory\n        .newHeapCharPointer(code)\n        .consume((charHandle) =>\n          this.ffi.QTS_Eval_MaybeAsync(\n            this.ctx.value,\n            charHandle.value,\n            filename,\n            detectModule,\n            flags\n          )\n        )\n    } catch (error) {\n      debugLog(\"QTS_Eval_MaybeAsync threw\", error)\n      throw error\n    }\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Similar to [[newFunction]].\n   * Convert an async host Javascript function into a synchronous QuickJS function value.\n   *\n   * Whenever QuickJS calls this function, the VM's stack will be unwound while\n   * waiting the async function to complete, and then restored when the returned\n   * promise resolves.\n   *\n   * Asyncified functions must never call other asyncified functions or\n   * `import`, even indirectly, because the stack cannot be unwound twice.\n   *\n   * See [Emscripten's docs on Asyncify](https://emscripten.org/docs/porting/asyncify.html).\n   */\n  newAsyncifiedFunction(name: string, fn: AsyncFunctionImplementation): QuickJSHandle {\n    return this.newFunction(name, fn as any)\n  }\n}\n"],"mappings":";;;;;;AAAA,MAAAA,SAAA,GAAAC,OAAA;AACA,MAAAC,OAAA,GAAAD,OAAA;AAOA,MAAAE,OAAA,GAAAF,OAAA;AAQA;;;;;;;AAOA,MAAaG,mBAAoB,SAAQJ,SAAA,CAAAK,cAAc;EAWrD;;;EAGA,MAAMC,aAAaA,CACjBC,IAAY,EACZC,QAAA,GAAmB,SAAS,EAC5B;EACAC,OAAqC;IAErC,MAAMC,YAAY,GAAID,OAAO,KAAKE,SAAS,GAAG,CAAC,GAAG,CAAsB;IACxE,MAAMC,KAAK,GAAG,IAAAT,OAAA,CAAAU,kBAAkB,EAACJ,OAAO,CAAc;IACtD,IAAIK,SAAS,GAAG,CAAmB;IACnC,IAAI;MACFA,SAAS,GAAG,MAAM,IAAI,CAACC,MAAM,CAC1BC,kBAAkB,CAACT,IAAI,CAAC,CACxBU,OAAO,CAAEC,UAAU,IAClB,IAAI,CAACC,GAAG,CAACC,mBAAmB,CAC1B,IAAI,CAACC,GAAG,CAACC,KAAK,EACdJ,UAAU,CAACI,KAAK,EAChBd,QAAQ,EACRE,YAAY,EACZE,KAAK,CACN,CACF;KACJ,CAAC,OAAOW,KAAK,EAAE;MACd,IAAArB,OAAA,CAAAsB,QAAQ,EAAC,2BAA2B,EAAED,KAAK,CAAC;MAC5C,MAAMA,KAAK;;IAEb,MAAME,QAAQ,GAAG,IAAI,CAACN,GAAG,CAACO,oBAAoB,CAAC,IAAI,CAACL,GAAG,CAACC,KAAK,EAAER,SAAS,CAAC;IACzE,IAAIW,QAAQ,EAAE;MACZ,IAAI,CAACN,GAAG,CAACQ,oBAAoB,CAAC,IAAI,CAACN,GAAG,CAACC,KAAK,EAAER,SAAS,CAAC;MACxD,OAAO;QAAES,KAAK,EAAE,IAAI,CAACR,MAAM,CAACa,eAAe,CAACH,QAAQ;MAAC,CAAE;;IAEzD,OAAO;MAAEH,KAAK,EAAE,IAAI,CAACP,MAAM,CAACa,eAAe,CAACd,SAAS;IAAC,CAAE;EAC1D;EAEA;;;;;;;;;;;;;EAaAe,qBAAqBA,CAACC,IAAY,EAAEC,EAA+B;IACjE,OAAO,IAAI,CAACC,WAAW,CAACF,IAAI,EAAEC,EAAS,CAAC;EAC1C;;AA9DFE,OAAA,CAAA7B,mBAAA,GAAAA,mBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}