{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.degenerator = void 0;\nconst util_1 = require(\"util\");\nconst escodegen_1 = require(\"escodegen\");\nconst esprima_1 = require(\"esprima\");\nconst ast_types_1 = require(\"ast-types\");\n/**\n * Compiles sync JavaScript code into JavaScript with async Functions.\n *\n * @param {String} code JavaScript string to convert\n * @param {Array} names Array of function names to add `await` operators to\n * @return {String} Converted JavaScript string with async/await injected\n * @api public\n */\nfunction degenerator(code, _names) {\n  if (!Array.isArray(_names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  }\n  // Duplicate the `names` array since it's rude to augment the user args\n  const names = _names.slice(0);\n  const ast = (0, esprima_1.parseScript)(code);\n  // First pass is to find the `function` nodes and turn them into async or\n  // generator functions only if their body includes `CallExpressions` to\n  // function in `names`. We also add the names of the functions to the `names`\n  // array. We'll iterate several time, as every iteration might add new items\n  // to the `names` array, until no new names were added in the iteration.\n  let lastNamesLength = 0;\n  do {\n    lastNamesLength = names.length;\n    (0, ast_types_1.visit)(ast, {\n      visitVariableDeclaration(path) {\n        if (path.node.declarations) {\n          for (let i = 0; i < path.node.declarations.length; i++) {\n            const declaration = path.node.declarations[i];\n            if (ast_types_1.namedTypes.VariableDeclarator.check(declaration) && ast_types_1.namedTypes.Identifier.check(declaration.init) && ast_types_1.namedTypes.Identifier.check(declaration.id) && checkName(declaration.init.name, names) && !checkName(declaration.id.name, names)) {\n              names.push(declaration.id.name);\n            }\n          }\n        }\n        return false;\n      },\n      visitAssignmentExpression(path) {\n        if (ast_types_1.namedTypes.Identifier.check(path.node.left) && ast_types_1.namedTypes.Identifier.check(path.node.right) && checkName(path.node.right.name, names) && !checkName(path.node.left.name, names)) {\n          names.push(path.node.left.name);\n        }\n        return false;\n      },\n      visitFunction(path) {\n        if (path.node.id) {\n          let shouldDegenerate = false;\n          (0, ast_types_1.visit)(path.node, {\n            visitCallExpression(path) {\n              if (checkNames(path.node, names)) {\n                shouldDegenerate = true;\n              }\n              return false;\n            }\n          });\n          if (!shouldDegenerate) {\n            return false;\n          }\n          // Got a \"function\" expression/statement,\n          // convert it into an async function\n          path.node.async = true;\n          // Add function name to `names` array\n          if (!checkName(path.node.id.name, names)) {\n            names.push(path.node.id.name);\n          }\n        }\n        this.traverse(path);\n      }\n    });\n  } while (lastNamesLength !== names.length);\n  // Second pass is for adding `await` statements to any function\n  // invocations that match the given `names` array.\n  (0, ast_types_1.visit)(ast, {\n    visitCallExpression(path) {\n      if (checkNames(path.node, names)) {\n        // A \"function invocation\" expression,\n        // we need to inject an `AwaitExpression`\n        const delegate = false;\n        const {\n          name,\n          parent: {\n            node: pNode\n          }\n        } = path;\n        const expr = ast_types_1.builders.awaitExpression(path.node, delegate);\n        if (ast_types_1.namedTypes.CallExpression.check(pNode)) {\n          pNode.arguments[name] = expr;\n        } else {\n          pNode[name] = expr;\n        }\n      }\n      this.traverse(path);\n    }\n  });\n  return (0, escodegen_1.generate)(ast);\n}\nexports.degenerator = degenerator;\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\nfunction checkNames({\n  callee\n}, names) {\n  let name;\n  if (ast_types_1.namedTypes.Identifier.check(callee)) {\n    name = callee.name;\n  } else if (ast_types_1.namedTypes.MemberExpression.check(callee)) {\n    if (ast_types_1.namedTypes.Identifier.check(callee.object) && ast_types_1.namedTypes.Identifier.check(callee.property)) {\n      name = `${callee.object.name}.${callee.property.name}`;\n    } else {\n      return false;\n    }\n  } else if (ast_types_1.namedTypes.FunctionExpression.check(callee)) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error(`Don't know how to get name for: ${callee.type}`);\n  }\n  return checkName(name, names);\n}\nfunction checkName(name, names) {\n  // now that we have the `name`, check if any entries match in the `names` array\n  for (let i = 0; i < names.length; i++) {\n    const n = names[i];\n    if (util_1.types.isRegExp(n)) {\n      if (n.test(name)) {\n        return true;\n      }\n    } else if (name === n) {\n      return true;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["util_1","require","escodegen_1","esprima_1","ast_types_1","degenerator","code","_names","Array","isArray","TypeError","names","slice","ast","parseScript","lastNamesLength","length","visit","visitVariableDeclaration","path","node","declarations","i","declaration","namedTypes","VariableDeclarator","check","Identifier","init","id","checkName","name","push","visitAssignmentExpression","left","right","visitFunction","shouldDegenerate","visitCallExpression","checkNames","async","traverse","delegate","parent","pNode","expr","builders","awaitExpression","CallExpression","arguments","generate","exports","callee","MemberExpression","object","property","FunctionExpression","Error","type","n","types","isRegExp","test"],"sources":["../src/degenerator.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}