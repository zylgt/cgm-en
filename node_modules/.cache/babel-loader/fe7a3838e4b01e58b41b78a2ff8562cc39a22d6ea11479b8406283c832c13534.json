{"ast":null,"code":"import { Message } from \"element-ui\";\nimport { eventBus } from '@/utils/eventBus';\nimport { generateKeys, arrayBufferToBase64, calShareKey } from '@/utils/ecdh';\nimport { aesEncrypt, aesDecrypt } from '@/utils/aes';\nlet socket = null; //实例对象\nlet lockReconnect = false; //是否真正建立连接\nlet port = [8971, 8972, 8973, 8974, 8975, 8976, 8977, 8978, 8979, 8980]; //端口号\nlet port_index = 0; //端口号下标\nlet repeat = 0; //重连次数\nlet status = 0; //连接状态 0开始建立连接 1连接成功 2交换秘钥成功 3连接失败 4连接中断\nlet share_key = null; //AES加密共享秘钥\nlet exchange_shareKey = \"com.ihealth.cgm\"; //AES加密共享秘钥\nlet privateKey = null; //私钥\n\nconst initwebSocket = async () => {\n  if (\"WebSocket\" in window) {\n    var wsUrl = 'ws://ivd.cgm3.com:' + port[port_index] + '/uploader';\n    console.log(wsUrl, '连接地址');\n    socket = new WebSocket(wsUrl);\n    status = 0;\n    socket.onerror = webSocketOnError;\n    socket.onmessage = webSocketOnMessage;\n    socket.onclose = closeWebsocket;\n    socket.onopen = openWebsocket;\n  } else {\n    Message.error({\n      showClose: true,\n      message: '您的浏览器不支持websocket，请更换Chrome或者Firefox'\n    });\n  }\n};\n\n//重置\nconst reset = () => {\n  repeat = 0;\n  status = 0;\n  port_index = 0;\n};\n//建立连接\nconst openWebsocket = async e => {\n  console.log(e, '已连接');\n  lockReconnect = true;\n  status = 1;\n  // 连接建立成功后开始协商秘钥\n  let publickey = await getEcdhPublicKey();\n  console.log(\"开始协商秘钥...\");\n  sendWebsocket({\n    \"path\": \"changekey\",\n    \"data\": {\n      \"publicKey\": publickey\n    }\n  });\n};\n// 重新连接\nconst reconnect = () => {\n  if (lockReconnect) {\n    return;\n  }\n  port_index++;\n  if (port_index > 9) {\n    port_index = 0;\n    repeat++;\n    if (repeat > 2) {\n      status = 3;\n      eventBus.$emit('socketStatusChange', status);\n      console.log('WebSocket 连接失败，端口都不被连接');\n      return;\n    }\n    console.log(`正在尝试第 ${repeat} 次重连...`);\n  }\n  initwebSocket();\n};\n\n// 发送数据\nconst sendWebsocket = data => {\n  if (!lockReconnect) {\n    console.log(\"webSocket未连接\");\n    return;\n  }\n  console.log(\"发送的内容: \" + JSON.stringify(data));\n  const path = data.path;\n  //对data内容加密\n  if (\"data\" in data) {\n    const key = path == \"changekey\" ? exchange_shareKey : shareKey;\n    data[\"data\"] = aesEncrypt(data[\"data\"], key);\n  }\n  let json = JSON.stringify(data);\n  socket.send(json);\n};\nconst webSocketOnError = e => {\n  console.log('发生错误', e);\n};\n// 接收数据\nconst webSocketOnMessage = async e => {\n  console.log('收到消息', e);\n  let info = JSON.parse(e.data);\n  let path = info.path;\n  let code = info.code;\n  let data_info = null;\n  if (code != 200) {\n    console.log('报错');\n    return;\n  }\n  if (path == \"changekey\") {\n    data_info = aesDecrypt(info.data, exchange_shareKey);\n    let procedure_public_key = data_info.publicKey;\n    let share_data = await calShareKey(privateKey, procedure_public_key);\n    share_key = arrayBufferToBase64(share_data);\n    getAppInfo();\n    console.log(\"协商秘钥结果: \" + share_key + \"\\n\");\n  } else {\n    data_info = aesDecrypt(info.data, shareKey);\n    eventBus.$emit('socketMessage', data_info);\n  }\n};\nconst closeWebsocket = e => {\n  lockReconnect = false;\n  if (e.code == 1000 || e.code > 1010) {\n    console.log('连接已关闭', e);\n  } else {\n    // 异常关闭，需要重连\n    reconnect();\n  }\n};\n//断开连接\nconst close = () => {\n  //WebSocket对象也有发送和关闭的两个方法，只需要在自定义方法中分别调用send()和close()即可实现。\n  socket.close();\n};\n\n//获取公钥\nconst getEcdhPublicKey = async () => {\n  const ecdh = await generateKeys();\n  privateKey = ecdh.privateKey;\n  //导出公钥转为base64字符串\n  const public_bytes = await window.crypto.subtle.exportKey(\"raw\", ecdh.publicKey);\n  const base64_public_key = arrayBufferToBase64(public_bytes);\n  return base64_public_key;\n};\n\n//获取驱动程序的版本信息\nconst getAppInfo = () => {\n  console.log(\"获取驱动程序的版本信息\");\n  let data = {\n    \"path\": \"getAppInfo\"\n  };\n  sendWebsocket(data);\n};\nexport default {\n  initwebSocket,\n  reset,\n  webSocketOnMessage\n};","map":{"version":3,"names":["Message","eventBus","generateKeys","arrayBufferToBase64","calShareKey","aesEncrypt","aesDecrypt","socket","lockReconnect","port","port_index","repeat","status","share_key","exchange_shareKey","privateKey","initwebSocket","window","wsUrl","console","log","WebSocket","onerror","webSocketOnError","onmessage","webSocketOnMessage","onclose","closeWebsocket","onopen","openWebsocket","error","showClose","message","reset","e","publickey","getEcdhPublicKey","sendWebsocket","reconnect","$emit","data","JSON","stringify","path","key","shareKey","json","send","info","parse","code","data_info","procedure_public_key","publicKey","share_data","getAppInfo","close","ecdh","public_bytes","crypto","subtle","exportKey","base64_public_key"],"sources":["/Users/hexuemin/Desktop/jiuan/CGM/CGMWeb/src/utils/webSocket.js"],"sourcesContent":["import { Message } from \"element-ui\";\nimport {eventBus} from '@/utils/eventBus'\nimport {generateKeys,arrayBufferToBase64,calShareKey} from '@/utils/ecdh'\nimport {aesEncrypt,aesDecrypt} from '@/utils/aes'\n\nlet socket = null; //实例对象\nlet lockReconnect = false; //是否真正建立连接\nlet port = [8971,8972,8973,8974,8975,8976,8977,8978,8979,8980]; //端口号\nlet port_index = 0; //端口号下标\nlet repeat = 0; //重连次数\nlet status = 0; //连接状态 0开始建立连接 1连接成功 2交换秘钥成功 3连接失败 4连接中断\nlet share_key = null //AES加密共享秘钥\nlet exchange_shareKey = \"com.ihealth.cgm\" //AES加密共享秘钥\nlet privateKey = null //私钥\n\nconst initwebSocket = async()=>{\n    if(\"WebSocket\" in window){\n        var wsUrl = 'ws://ivd.cgm3.com:'+port[port_index]+'/uploader'\n        console.log(wsUrl,'连接地址')\n        socket = new WebSocket(wsUrl);\n        status = 0\n        socket.onerror = webSocketOnError;\n        socket.onmessage = webSocketOnMessage;\n        socket.onclose = closeWebsocket;\n        socket.onopen = openWebsocket;\n    }else{\n        Message.error({\n            showClose: true,\n            message: '您的浏览器不支持websocket，请更换Chrome或者Firefox'\n        });\n    }\n}\n\n\n//重置\nconst reset =() => {\n    repeat=0\n    status=0\n    port_index = 0\n\n}\n//建立连接\nconst openWebsocket = async(e) => {\n    console.log(e,'已连接')\n    lockReconnect = true\n    status = 1\n    // 连接建立成功后开始协商秘钥\n    let publickey = await getEcdhPublicKey()\n    console.log(\"开始协商秘钥...\")\n    sendWebsocket({\"path\":\"changekey\", \"data\":{\"publicKey\":publickey}})\n}\n// 重新连接\nconst reconnect = () =>{\n    if(lockReconnect){\n        return ;\n    }\n    port_index++\n    if(port_index>9){\n        port_index = 0\n        repeat++\n        if(repeat>2){\n            status = 3\n            eventBus.$emit('socketStatusChange',status)\n            console.log('WebSocket 连接失败，端口都不被连接');\n            return;\n        }\n        console.log(`正在尝试第 ${repeat} 次重连...`);\n    }\n    initwebSocket()\n}\n\n// 发送数据\nconst sendWebsocket =(data) =>{\n    if(!lockReconnect){\n        console.log(\"webSocket未连接\")\n        return\n    }\n    console.log(\"发送的内容: \" + JSON.stringify(data))\n    const path = data.path\n    //对data内容加密\n    if (\"data\" in data){\n        const key = path == \"changekey\" ? exchange_shareKey : shareKey\n        data[\"data\"] = aesEncrypt(data[\"data\"],key)  \n    }\n    let json = JSON.stringify(data)\n    socket.send(json)\n}\n   \n\nconst webSocketOnError =(e) => {\n    console.log('发生错误',e)\n}  \n// 接收数据\nconst webSocketOnMessage = async(e) => {\n    console.log('收到消息',e)\n    let info = JSON.parse(e.data)\n    let path = info.path\n    let code = info.code\n    let data_info = null\n    if(code!=200){\n        console.log('报错')\n        return\n    }\n    if(path == \"changekey\"){\n        data_info = aesDecrypt(info.data,exchange_shareKey)\n        let procedure_public_key = data_info.publicKey\n        let share_data = await calShareKey(privateKey,procedure_public_key)\n        share_key = arrayBufferToBase64(share_data)\n        getAppInfo()\n        console.log(\"协商秘钥结果: \" + share_key + \"\\n\")\n    }else{\n        data_info = aesDecrypt(info.data,shareKey)\n        eventBus.$emit('socketMessage',data_info)\n    }\n\n}\n\nconst closeWebsocket=(e) => {\n   \n    lockReconnect = false\n    if(e.code==1000||e.code>1010){\n        console.log('连接已关闭',e)\n    }else{\n        // 异常关闭，需要重连\n        reconnect();\n    }\n} \n//断开连接\nconst close =() => {\n    //WebSocket对象也有发送和关闭的两个方法，只需要在自定义方法中分别调用send()和close()即可实现。\n      socket.close();\n}   \n\n\n//获取公钥\nconst getEcdhPublicKey = async()=>{\n    const ecdh = await generateKeys()\n    privateKey = ecdh.privateKey\n    //导出公钥转为base64字符串\n    const public_bytes = await window.crypto.subtle.exportKey(\"raw\", ecdh.publicKey);\n    const base64_public_key = arrayBufferToBase64(public_bytes)\n    return base64_public_key\n}\n\n//获取驱动程序的版本信息\nconst getAppInfo =() =>{\n    console.log(\"获取驱动程序的版本信息\")\n    let data = {\"path\": \"getAppInfo\"}\n    sendWebsocket(data)\n}\n\n\n\n\n\nexport default{initwebSocket,reset,webSocketOnMessage}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}