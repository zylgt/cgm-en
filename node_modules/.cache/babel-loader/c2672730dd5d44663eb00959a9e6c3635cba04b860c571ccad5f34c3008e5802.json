{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuickJSContext = void 0;\nconst debug_1 = require(\"./debug\");\nconst deferred_promise_1 = require(\"./deferred-promise\");\nconst errors_1 = require(\"./errors\");\nconst lifetime_1 = require(\"./lifetime\");\nconst memory_1 = require(\"./memory\");\nconst types_1 = require(\"./types\");\n/**\n * @private\n */\nclass ContextMemory extends memory_1.ModuleMemory {\n  /** @private */\n  constructor(args) {\n    super(args.module);\n    this.scope = new lifetime_1.Scope();\n    this.copyJSValue = ptr => {\n      return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr);\n    };\n    this.freeJSValue = ptr => {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr);\n    };\n    args.ownedLifetimes?.forEach(lifetime => this.scope.manage(lifetime));\n    this.owner = args.owner;\n    this.module = args.module;\n    this.ffi = args.ffi;\n    this.rt = args.rt;\n    this.ctx = this.scope.manage(args.ctx);\n  }\n  get alive() {\n    return this.scope.alive;\n  }\n  dispose() {\n    return this.scope.dispose();\n  }\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage(lifetime) {\n    return this.scope.manage(lifetime);\n  }\n  consumeJSCharPointer(ptr) {\n    const str = this.module.UTF8ToString(ptr);\n    this.ffi.QTS_FreeCString(this.ctx.value, ptr);\n    return str;\n  }\n  heapValueHandle(ptr) {\n    return new lifetime_1.Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner);\n  }\n}\n/**\n * QuickJSContext wraps a QuickJS Javascript context (JSContext*) within a\n * runtime. The contexts within the same runtime may exchange objects freely.\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain. The {@link runtime} references the context's runtime.\n *\n * This class's methods return {@link QuickJSHandle}, which wrap C pointers (JSValue*).\n * It's the caller's responsibility to call `.dispose()` on any\n * handles you create to free memory once you're done with the handle.\n *\n * Use {@link QuickJSRuntime.newContext} or {@link QuickJSWASMModule.newContext}\n * to create a new QuickJSContext.\n *\n * Create QuickJS values inside the interpreter with methods like\n * [[newNumber]], [[newString]], [[newArray]], [[newObject]],\n * [[newFunction]], and [[newPromise]].\n *\n * Call [[setProp]] or [[defineProp]] to customize objects. Use those methods\n * with [[global]] to expose the values you create to the interior of the\n * interpreter, so they can be used in [[evalCode]].\n *\n * Use [[evalCode]] or [[callFunction]] to execute Javascript inside the VM. If\n * you're using asynchronous code inside the QuickJSContext, you may need to also\n * call [[executePendingJobs]]. Executing code inside the runtime returns a\n * result object representing successful execution or an error. You must dispose\n * of any such results to avoid leaking memory inside the VM.\n *\n * Implement memory and CPU constraints at the runtime level, using [[runtime]].\n * See {@link QuickJSRuntime} for more information.\n *\n */\n// TODO: Manage own callback registration\nclass QuickJSContext {\n  /**\n   * Use {@link QuickJS.createVm} to create a QuickJSContext instance.\n   */\n  constructor(args) {\n    /** @private */\n    this._undefined = undefined;\n    /** @private */\n    this._null = undefined;\n    /** @private */\n    this._false = undefined;\n    /** @private */\n    this._true = undefined;\n    /** @private */\n    this._global = undefined;\n    /** @private */\n    this._BigInt = undefined;\n    /** @private */\n    this.fnNextId = -32768; // min value of signed 16bit int used by Quickjs\n    /** @private */\n    this.fnMaps = new Map();\n    /**\n     * @hidden\n     */\n    this.cToHostCallbacks = {\n      callFunction: (ctx, this_ptr, argc, argv, fn_id) => {\n        if (ctx !== this.ctx.value) {\n          throw new Error(\"QuickJSContext instance received C -> JS call with mismatched ctx\");\n        }\n        const fn = this.getFunction(fn_id);\n        if (!fn) {\n          // this \"throw\" is not catch-able from the TS side. could we somehow handle this higher up?\n          throw new Error(`QuickJSContext had no callback with id ${fn_id}`);\n        }\n        return lifetime_1.Scope.withScopeMaybeAsync(this, function* (awaited, scope) {\n          const thisHandle = scope.manage(new lifetime_1.WeakLifetime(this_ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));\n          const argHandles = new Array(argc);\n          for (let i = 0; i < argc; i++) {\n            const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i);\n            argHandles[i] = scope.manage(new lifetime_1.WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));\n          }\n          try {\n            const result = yield* awaited(fn.apply(thisHandle, argHandles));\n            if (result) {\n              if (\"error\" in result && result.error) {\n                (0, debug_1.debugLog)(\"throw error\", result.error);\n                throw result.error;\n              }\n              const handle = scope.manage(result instanceof lifetime_1.Lifetime ? result : result.value);\n              return this.ffi.QTS_DupValuePointer(this.ctx.value, handle.value);\n            }\n            return 0;\n          } catch (error) {\n            return this.errorToHandle(error).consume(errorHandle => this.ffi.QTS_Throw(this.ctx.value, errorHandle.value));\n          }\n        });\n      }\n    };\n    this.runtime = args.runtime;\n    this.module = args.module;\n    this.ffi = args.ffi;\n    this.rt = args.rt;\n    this.ctx = args.ctx;\n    this.memory = new ContextMemory({\n      ...args,\n      owner: this.runtime\n    });\n    args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks);\n    this.dump = this.dump.bind(this);\n    this.getString = this.getString.bind(this);\n    this.getNumber = this.getNumber.bind(this);\n    this.resolvePromise = this.resolvePromise.bind(this);\n  }\n  // @implement Disposable ----------------------------------------------------\n  get alive() {\n    return this.memory.alive;\n  }\n  /**\n   * Dispose of this VM's underlying resources.\n   *\n   * @throws Calling this method without disposing of all created handles\n   * will result in an error.\n   */\n  dispose() {\n    this.memory.dispose();\n  }\n  // Globals ------------------------------------------------------------------\n  /**\n   * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).\n   */\n  get undefined() {\n    if (this._undefined) {\n      return this._undefined;\n    }\n    // Undefined is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetUndefined();\n    return this._undefined = new lifetime_1.StaticLifetime(ptr);\n  }\n  /**\n   * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).\n   */\n  get null() {\n    if (this._null) {\n      return this._null;\n    }\n    // Null is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetNull();\n    return this._null = new lifetime_1.StaticLifetime(ptr);\n  }\n  /**\n   * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).\n   */\n  get true() {\n    if (this._true) {\n      return this._true;\n    }\n    // True is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetTrue();\n    return this._true = new lifetime_1.StaticLifetime(ptr);\n  }\n  /**\n   * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).\n   */\n  get false() {\n    if (this._false) {\n      return this._false;\n    }\n    // False is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetFalse();\n    return this._false = new lifetime_1.StaticLifetime(ptr);\n  }\n  /**\n   * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).\n   * A handle to the global object inside the interpreter.\n   * You can set properties to create global variables.\n   */\n  get global() {\n    if (this._global) {\n      return this._global;\n    }\n    // The global is a JSValue, but since it's lifetime is as long as the VM's,\n    // we should manage it.\n    const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value);\n    // Automatically clean up this reference when we dispose\n    this.memory.manage(this.memory.heapValueHandle(ptr));\n    // This isn't technically a static lifetime, but since it has the same\n    // lifetime as the VM, it's okay to fake one since when the VM is\n    // disposed, no other functions will accept the value.\n    this._global = new lifetime_1.StaticLifetime(ptr, this.runtime);\n    return this._global;\n  }\n  // New values ---------------------------------------------------------------\n  /**\n   * Converts a Javascript number into a QuickJS value.\n   */\n  newNumber(num) {\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num));\n  }\n  /**\n   * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.\n   */\n  newString(str) {\n    const ptr = this.memory.newHeapCharPointer(str).consume(charHandle => this.ffi.QTS_NewString(this.ctx.value, charHandle.value));\n    return this.memory.heapValueHandle(ptr);\n  }\n  /**\n   * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.\n   * No two symbols created with this function will be the same value.\n   */\n  newUniqueSymbol(description) {\n    const key = (typeof description === \"symbol\" ? description.description : description) ?? \"\";\n    const ptr = this.memory.newHeapCharPointer(key).consume(charHandle => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 0));\n    return this.memory.heapValueHandle(ptr);\n  }\n  /**\n   * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.\n   * All symbols created with the same key will be the same value.\n   */\n  newSymbolFor(key) {\n    const description = (typeof key === \"symbol\" ? key.description : key) ?? \"\";\n    const ptr = this.memory.newHeapCharPointer(description).consume(charHandle => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 1));\n    return this.memory.heapValueHandle(ptr);\n  }\n  /**\n   * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.\n   */\n  newBigInt(num) {\n    if (!this._BigInt) {\n      const bigIntHandle = this.getProp(this.global, \"BigInt\");\n      this.memory.manage(bigIntHandle);\n      this._BigInt = new lifetime_1.StaticLifetime(bigIntHandle.value, this.runtime);\n    }\n    const bigIntHandle = this._BigInt;\n    const asString = String(num);\n    return this.newString(asString).consume(handle => this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle)));\n  }\n  /**\n   * `{}`.\n   * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).\n   *\n   * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).\n   */\n  newObject(prototype) {\n    if (prototype) {\n      this.runtime.assertOwned(prototype);\n    }\n    const ptr = prototype ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype.value) : this.ffi.QTS_NewObject(this.ctx.value);\n    return this.memory.heapValueHandle(ptr);\n  }\n  /**\n   * `[]`.\n   * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).\n   */\n  newArray() {\n    const ptr = this.ffi.QTS_NewArray(this.ctx.value);\n    return this.memory.heapValueHandle(ptr);\n  }\n  newPromise(value) {\n    const deferredPromise = lifetime_1.Scope.withScope(scope => {\n      const mutablePointerArray = scope.manage(this.memory.newMutablePointerArray(2));\n      const promisePtr = this.ffi.QTS_NewPromiseCapability(this.ctx.value, mutablePointerArray.value.ptr);\n      const promiseHandle = this.memory.heapValueHandle(promisePtr);\n      const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map(jsvaluePtr => this.memory.heapValueHandle(jsvaluePtr));\n      return new deferred_promise_1.QuickJSDeferredPromise({\n        context: this,\n        promiseHandle,\n        resolveHandle,\n        rejectHandle\n      });\n    });\n    if (value && typeof value === \"function\") {\n      value = new Promise(value);\n    }\n    if (value) {\n      Promise.resolve(value).then(deferredPromise.resolve, error => error instanceof lifetime_1.Lifetime ? deferredPromise.reject(error) : this.newError(error).consume(deferredPromise.reject));\n    }\n    return deferredPromise;\n  }\n  /**\n   * Convert a Javascript function into a QuickJS function value.\n   * See [[VmFunctionImplementation]] for more details.\n   *\n   * A [[VmFunctionImplementation]] should not free its arguments or its return\n   * value. A VmFunctionImplementation should also not retain any references to\n   * its return value.\n   *\n   * To implement an async function, create a promise with [[newPromise]], then\n   * return the deferred promise handle from `deferred.handle` from your\n   * function implementation:\n   *\n   * ```\n   * const deferred = vm.newPromise()\n   * someNativeAsyncFunction().then(deferred.resolve)\n   * return deferred.handle\n   * ```\n   */\n  newFunction(name, fn) {\n    const fnId = ++this.fnNextId;\n    this.setFunction(fnId, fn);\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name));\n  }\n  newError(error) {\n    const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value));\n    if (error && typeof error === \"object\") {\n      if (error.name !== undefined) {\n        this.newString(error.name).consume(handle => this.setProp(errorHandle, \"name\", handle));\n      }\n      if (error.message !== undefined) {\n        this.newString(error.message).consume(handle => this.setProp(errorHandle, \"message\", handle));\n      }\n    } else if (typeof error === \"string\") {\n      this.newString(error).consume(handle => this.setProp(errorHandle, \"message\", handle));\n    } else if (error !== undefined) {\n      // This isn't supported in the type signature but maybe it will make life easier.\n      this.newString(String(error)).consume(handle => this.setProp(errorHandle, \"message\", handle));\n    }\n    return errorHandle;\n  }\n  // Read values --------------------------------------------------------------\n  /**\n   * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).\n   *\n   * @remarks\n   * Does not support BigInt values correctly.\n   */\n  typeof(handle) {\n    this.runtime.assertOwned(handle);\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle.value));\n  }\n  /**\n   * Converts `handle` into a Javascript number.\n   * @returns `NaN` on error, otherwise a `number`.\n   */\n  getNumber(handle) {\n    this.runtime.assertOwned(handle);\n    return this.ffi.QTS_GetFloat64(this.ctx.value, handle.value);\n  }\n  /**\n   * Converts `handle` to a Javascript string.\n   */\n  getString(handle) {\n    this.runtime.assertOwned(handle);\n    return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle.value));\n  }\n  /**\n   * Converts `handle` into a Javascript symbol. If the symbol is in the global\n   * registry in the guest, it will be created with Symbol.for on the host.\n   */\n  getSymbol(handle) {\n    this.runtime.assertOwned(handle);\n    const key = this.memory.consumeJSCharPointer(this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle.value));\n    const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle.value);\n    return isGlobal ? Symbol.for(key) : Symbol(key);\n  }\n  /**\n   * Converts `handle` to a Javascript bigint.\n   */\n  getBigInt(handle) {\n    this.runtime.assertOwned(handle);\n    const asString = this.getString(handle);\n    return BigInt(asString);\n  }\n  /**\n   * `Promise.resolve(value)`.\n   * Convert a handle containing a Promise-like value inside the VM into an\n   * actual promise on the host.\n   *\n   * @remarks\n   * You may need to call [[executePendingJobs]] to ensure that the promise is resolved.\n   *\n   * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.\n   */\n  resolvePromise(promiseLikeHandle) {\n    this.runtime.assertOwned(promiseLikeHandle);\n    const vmResolveResult = lifetime_1.Scope.withScope(scope => {\n      const vmPromise = scope.manage(this.getProp(this.global, \"Promise\"));\n      const vmPromiseResolve = scope.manage(this.getProp(vmPromise, \"resolve\"));\n      return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle);\n    });\n    if (vmResolveResult.error) {\n      return Promise.resolve(vmResolveResult);\n    }\n    return new Promise(resolve => {\n      lifetime_1.Scope.withScope(scope => {\n        const resolveHandle = scope.manage(this.newFunction(\"resolve\", value => {\n          resolve({\n            value: value && value.dup()\n          });\n        }));\n        const rejectHandle = scope.manage(this.newFunction(\"reject\", error => {\n          resolve({\n            error: error && error.dup()\n          });\n        }));\n        const promiseHandle = scope.manage(vmResolveResult.value);\n        const promiseThenHandle = scope.manage(this.getProp(promiseHandle, \"then\"));\n        this.unwrapResult(this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle)).dispose();\n      });\n    });\n  }\n  // Properties ---------------------------------------------------------------\n  /**\n   * `handle[key]`.\n   * Get a property from a JSValue.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string (which will be converted automatically).\n   */\n  getProp(handle, key) {\n    this.runtime.assertOwned(handle);\n    const ptr = this.borrowPropertyKey(key).consume(quickJSKey => this.ffi.QTS_GetProp(this.ctx.value, handle.value, quickJSKey.value));\n    const result = this.memory.heapValueHandle(ptr);\n    return result;\n  }\n  /**\n   * `handle[key] = value`.\n   * Set a property on a JSValue.\n   *\n   * @remarks\n   * Note that the QuickJS authors recommend using [[defineProp]] to define new\n   * properties.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  setProp(handle, key, value) {\n    this.runtime.assertOwned(handle);\n    // free newly allocated value if key was a string or number. No-op if string was already\n    // a QuickJS handle.\n    this.borrowPropertyKey(key).consume(quickJSKey => this.ffi.QTS_SetProp(this.ctx.value, handle.value, quickJSKey.value, value.value));\n  }\n  /**\n   * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  defineProp(handle, key, descriptor) {\n    this.runtime.assertOwned(handle);\n    lifetime_1.Scope.withScope(scope => {\n      const quickJSKey = scope.manage(this.borrowPropertyKey(key));\n      const value = descriptor.value || this.undefined;\n      const configurable = Boolean(descriptor.configurable);\n      const enumerable = Boolean(descriptor.enumerable);\n      const hasValue = Boolean(descriptor.value);\n      const get = descriptor.get ? scope.manage(this.newFunction(descriptor.get.name, descriptor.get)) : this.undefined;\n      const set = descriptor.set ? scope.manage(this.newFunction(descriptor.set.name, descriptor.set)) : this.undefined;\n      this.ffi.QTS_DefineProp(this.ctx.value, handle.value, quickJSKey.value, value.value, get.value, set.value, configurable, enumerable, hasValue);\n    });\n  }\n  // Evaluation ---------------------------------------------------------------\n  /**\n   * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).\n   * Call a JSValue as a function.\n   *\n   * See [[unwrapResult]], which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use [[resolvePromise]] to convert it to a native promise and\n   * [[executePendingJobs]] to finish evaluating the promise.\n   *\n   * @returns A result. If the function threw synchronously, `result.error` be a\n   * handle to the exception. Otherwise `result.value` will be a handle to the\n   * value.\n   */\n  callFunction(func, thisVal, ...args) {\n    this.runtime.assertOwned(func);\n    const resultPtr = this.memory.toPointerArray(args).consume(argsArrayPtr => this.ffi.QTS_Call(this.ctx.value, func.value, thisVal.value, args.length, argsArrayPtr.value));\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);\n      return {\n        error: this.memory.heapValueHandle(errorPtr)\n      };\n    }\n    return {\n      value: this.memory.heapValueHandle(resultPtr)\n    };\n  }\n  /**\n   * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).\n   * Evaluates the Javascript source `code` in the global scope of this VM.\n   * When working with async code, you many need to call [[executePendingJobs]]\n   * to execute callbacks pending after synchronous evaluation returns.\n   *\n   * See [[unwrapResult]], which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use [[resolvePromise]] to convert it to a native promise and\n   * [[executePendingJobs]] to finish evaluating the promise.\n   *\n   * *Note*: to protect against infinite loops, provide an interrupt handler to\n   * [[setInterruptHandler]]. You can use [[shouldInterruptAfterDeadline]] to\n   * create a time-based deadline.\n   *\n   * @returns The last statement's value. If the code threw synchronously,\n   * `result.error` will be a handle to the exception. If execution was\n   * interrupted, the error will have name `InternalError` and message\n   * `interrupted`.\n   */\n  evalCode(code, filename = \"eval.js\",\n  /**\n   * If no options are passed, a heuristic will be used to detect if `code` is\n   * an ES module.\n   *\n   * See [[EvalFlags]] for number semantics.\n   */\n  options) {\n    const detectModule = options === undefined ? 1 : 0;\n    const flags = (0, types_1.evalOptionsToFlags)(options);\n    const resultPtr = this.memory.newHeapCharPointer(code).consume(charHandle => this.ffi.QTS_Eval(this.ctx.value, charHandle.value, filename, detectModule, flags));\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);\n      return {\n        error: this.memory.heapValueHandle(errorPtr)\n      };\n    }\n    return {\n      value: this.memory.heapValueHandle(resultPtr)\n    };\n  }\n  /**\n   * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.\n   * @experimental\n   */\n  throw(error) {\n    return this.errorToHandle(error).consume(handle => this.ffi.QTS_Throw(this.ctx.value, handle.value));\n  }\n  /**\n   * @private\n   */\n  borrowPropertyKey(key) {\n    if (typeof key === \"number\") {\n      return this.newNumber(key);\n    }\n    if (typeof key === \"string\") {\n      return this.newString(key);\n    }\n    // key is already a JSValue, but we're borrowing it. Return a static handle\n    // for internal use only.\n    return new lifetime_1.StaticLifetime(key.value, this.runtime);\n  }\n  /**\n   * @private\n   */\n  getMemory(rt) {\n    if (rt === this.rt.value) {\n      return this.memory;\n    } else {\n      throw new Error(\"Private API. Cannot get memory from a different runtime\");\n    }\n  }\n  // Utilities ----------------------------------------------------------------\n  /**\n   * Dump a JSValue to Javascript in a best-effort fashion.\n   * Returns `handle.toString()` if it cannot be serialized to JSON.\n   */\n  dump(handle) {\n    this.runtime.assertOwned(handle);\n    const type = this.typeof(handle);\n    if (type === \"string\") {\n      return this.getString(handle);\n    } else if (type === \"number\") {\n      return this.getNumber(handle);\n    } else if (type === \"bigint\") {\n      return this.getBigInt(handle);\n    } else if (type === \"undefined\") {\n      return undefined;\n    } else if (type === \"symbol\") {\n      return this.getSymbol(handle);\n    }\n    const str = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle.value));\n    try {\n      return JSON.parse(str);\n    } catch (err) {\n      return str;\n    }\n  }\n  /**\n   * Unwrap a SuccessOrFail result such as a [[VmCallResult]] or a\n   * [[ExecutePendingJobsResult]], where the fail branch contains a handle to a QuickJS error value.\n   * If the result is a success, returns the value.\n   * If the result is an error, converts the error to a native object and throws the error.\n   */\n  unwrapResult(result) {\n    if (result.error) {\n      const context = \"context\" in result.error ? result.error.context : this;\n      const cause = result.error.consume(error => this.dump(error));\n      if (cause && typeof cause === \"object\" && typeof cause.message === \"string\") {\n        const {\n          message,\n          name,\n          stack\n        } = cause;\n        const exception = new errors_1.QuickJSUnwrapError(\"\");\n        const hostStack = exception.stack;\n        if (typeof name === \"string\") {\n          exception.name = cause.name;\n        }\n        if (typeof stack === \"string\") {\n          exception.stack = `${name}: ${message}\\n${cause.stack}Host: ${hostStack}`;\n        }\n        Object.assign(exception, {\n          cause,\n          context,\n          message\n        });\n        throw exception;\n      }\n      throw new errors_1.QuickJSUnwrapError(cause, context);\n    }\n    return result.value;\n  }\n  /** @private */\n  getFunction(fn_id) {\n    const map_id = fn_id >> 8;\n    const fnMap = this.fnMaps.get(map_id);\n    if (!fnMap) {\n      return undefined;\n    }\n    return fnMap.get(fn_id);\n  }\n  /** @private */\n  setFunction(fn_id, handle) {\n    const map_id = fn_id >> 8;\n    let fnMap = this.fnMaps.get(map_id);\n    if (!fnMap) {\n      fnMap = new Map();\n      this.fnMaps.set(map_id, fnMap);\n    }\n    return fnMap.set(fn_id, handle);\n  }\n  errorToHandle(error) {\n    if (error instanceof lifetime_1.Lifetime) {\n      return error;\n    }\n    return this.newError(error);\n  }\n}\nexports.QuickJSContext = QuickJSContext;","map":{"version":3,"names":["debug_1","require","deferred_promise_1","errors_1","lifetime_1","memory_1","types_1","ContextMemory","ModuleMemory","constructor","args","module","scope","Scope","copyJSValue","ptr","ffi","QTS_DupValuePointer","ctx","value","freeJSValue","QTS_FreeValuePointer","ownedLifetimes","forEach","lifetime","manage","owner","rt","alive","dispose","consumeJSCharPointer","str","UTF8ToString","QTS_FreeCString","heapValueHandle","Lifetime","QuickJSContext","_undefined","undefined","_null","_false","_true","_global","_BigInt","fnNextId","fnMaps","Map","cToHostCallbacks","callFunction","this_ptr","argc","argv","fn_id","Error","fn","getFunction","withScopeMaybeAsync","awaited","thisHandle","WeakLifetime","memory","runtime","argHandles","Array","i","QTS_ArgvGetJSValueConstPointer","result","apply","error","debugLog","handle","errorToHandle","consume","errorHandle","QTS_Throw","callbacks","setContextCallbacks","dump","bind","getString","getNumber","resolvePromise","QTS_GetUndefined","StaticLifetime","null","QTS_GetNull","true","QTS_GetTrue","false","QTS_GetFalse","global","QTS_GetGlobalObject","newNumber","num","QTS_NewFloat64","newString","newHeapCharPointer","charHandle","QTS_NewString","newUniqueSymbol","description","key","QTS_NewSymbol","newSymbolFor","newBigInt","bigIntHandle","getProp","asString","String","unwrapResult","newObject","prototype","assertOwned","QTS_NewObjectProto","QTS_NewObject","newArray","QTS_NewArray","newPromise","deferredPromise","withScope","mutablePointerArray","newMutablePointerArray","promisePtr","QTS_NewPromiseCapability","promiseHandle","resolveHandle","rejectHandle","from","typedArray","map","jsvaluePtr","QuickJSDeferredPromise","context","Promise","resolve","then","reject","newError","newFunction","name","fnId","setFunction","QTS_NewFunction","QTS_NewError","setProp","message","typeof","consumeHeapCharPointer","QTS_Typeof","QTS_GetFloat64","QTS_GetString","getSymbol","QTS_GetSymbolDescriptionOrKey","isGlobal","QTS_IsGlobalSymbol","Symbol","for","getBigInt","BigInt","promiseLikeHandle","vmResolveResult","vmPromise","vmPromiseResolve","dup","promiseThenHandle","borrowPropertyKey","quickJSKey","QTS_GetProp","QTS_SetProp","defineProp","descriptor","configurable","Boolean","enumerable","hasValue","get","set","QTS_DefineProp","func","thisVal","resultPtr","toPointerArray","argsArrayPtr","QTS_Call","length","errorPtr","QTS_ResolveException","evalCode","code","filename","options","detectModule","flags","evalOptionsToFlags","QTS_Eval","throw","getMemory","type","QTS_Dump","JSON","parse","err","cause","stack","exception","QuickJSUnwrapError","hostStack","Object","assign","map_id","fnMap","exports"],"sources":["../ts/context.ts"],"sourcesContent":["import { debugLog } from \"./debug\"\nimport { QuickJSDeferredPromise } from \"./deferred-promise\"\nimport type { EitherModule } from \"./emscripten-types\"\nimport { QuickJSUnwrapError } from \"./errors\"\nimport {\n  EvalDetectModule,\n  EvalFlags,\n  JSBorrowedCharPointer,\n  JSContextPointer,\n  JSModuleDefPointer,\n  JSRuntimePointer,\n  JSValueConstPointer,\n  JSValuePointer,\n  JSValuePointerPointer,\n  JSVoidPointer,\n} from \"./types-ffi\"\nimport { Disposable, Lifetime, Scope, StaticLifetime, WeakLifetime } from \"./lifetime\"\nimport { ModuleMemory } from \"./memory\"\nimport { ContextCallbacks, QuickJSModuleCallbacks } from \"./module\"\nimport { QuickJSRuntime } from \"./runtime\"\nimport {\n  ContextEvalOptions,\n  EitherFFI,\n  evalOptionsToFlags,\n  JSValue,\n  PromiseExecutor,\n  QuickJSHandle,\n} from \"./types\"\nimport {\n  LowLevelJavascriptVm,\n  SuccessOrFail,\n  VmCallResult,\n  VmFunctionImplementation,\n  VmPropertyDescriptor,\n} from \"./vm-interface\"\n\n/**\n * Property key for getting or setting a property on a handle with\n * [[QuickJSContext.getProp]], [[QuickJSContext.setProp]], or [[QuickJSContext.defineProp]].\n */\nexport type QuickJSPropertyKey = number | string | QuickJSHandle\n\n/**\n * @private\n */\nclass ContextMemory extends ModuleMemory implements Disposable {\n  readonly owner: QuickJSRuntime\n  readonly ctx: Lifetime<JSContextPointer>\n  readonly rt: Lifetime<JSRuntimePointer>\n  readonly module: EitherModule\n  readonly ffi: EitherFFI\n  readonly scope = new Scope()\n\n  /** @private */\n  constructor(args: {\n    owner: QuickJSRuntime\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    ownedLifetimes?: Disposable[]\n  }) {\n    super(args.module)\n    args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime))\n    this.owner = args.owner\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = this.scope.manage(args.ctx)\n  }\n\n  get alive() {\n    return this.scope.alive\n  }\n\n  dispose() {\n    return this.scope.dispose()\n  }\n\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage<T extends Disposable>(lifetime: T): T {\n    return this.scope.manage(lifetime)\n  }\n\n  copyJSValue = (ptr: JSValuePointer | JSValueConstPointer) => {\n    return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr)\n  }\n\n  freeJSValue = (ptr: JSValuePointer) => {\n    this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr)\n  }\n\n  consumeJSCharPointer(ptr: JSBorrowedCharPointer): string {\n    const str = this.module.UTF8ToString(ptr)\n    this.ffi.QTS_FreeCString(this.ctx.value, ptr)\n    return str\n  }\n\n  heapValueHandle(ptr: JSValuePointer): JSValue {\n    return new Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner)\n  }\n}\n\n/**\n * QuickJSContext wraps a QuickJS Javascript context (JSContext*) within a\n * runtime. The contexts within the same runtime may exchange objects freely.\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain. The {@link runtime} references the context's runtime.\n *\n * This class's methods return {@link QuickJSHandle}, which wrap C pointers (JSValue*).\n * It's the caller's responsibility to call `.dispose()` on any\n * handles you create to free memory once you're done with the handle.\n *\n * Use {@link QuickJSRuntime.newContext} or {@link QuickJSWASMModule.newContext}\n * to create a new QuickJSContext.\n *\n * Create QuickJS values inside the interpreter with methods like\n * [[newNumber]], [[newString]], [[newArray]], [[newObject]],\n * [[newFunction]], and [[newPromise]].\n *\n * Call [[setProp]] or [[defineProp]] to customize objects. Use those methods\n * with [[global]] to expose the values you create to the interior of the\n * interpreter, so they can be used in [[evalCode]].\n *\n * Use [[evalCode]] or [[callFunction]] to execute Javascript inside the VM. If\n * you're using asynchronous code inside the QuickJSContext, you may need to also\n * call [[executePendingJobs]]. Executing code inside the runtime returns a\n * result object representing successful execution or an error. You must dispose\n * of any such results to avoid leaking memory inside the VM.\n *\n * Implement memory and CPU constraints at the runtime level, using [[runtime]].\n * See {@link QuickJSRuntime} for more information.\n *\n */\n// TODO: Manage own callback registration\nexport class QuickJSContext implements LowLevelJavascriptVm<QuickJSHandle>, Disposable {\n  /**\n   * The runtime that created this context.\n   */\n  public readonly runtime: QuickJSRuntime\n\n  /** @private */\n  protected readonly ctx: Lifetime<JSContextPointer>\n  /** @private */\n  protected readonly rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected readonly module: EitherModule\n  /** @private */\n  protected readonly ffi: EitherFFI\n  /** @private */\n  protected memory: ContextMemory\n\n  /** @private */\n  protected _undefined: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _null: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _false: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _true: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _global: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _BigInt: QuickJSHandle | undefined = undefined\n\n  /**\n   * Use {@link QuickJS.createVm} to create a QuickJSContext instance.\n   */\n  constructor(args: {\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    runtime: QuickJSRuntime\n    ownedLifetimes?: Disposable[]\n    callbacks: QuickJSModuleCallbacks\n  }) {\n    this.runtime = args.runtime\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = args.ctx\n    this.memory = new ContextMemory({\n      ...args,\n      owner: this.runtime,\n    })\n    args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks)\n    this.dump = this.dump.bind(this)\n    this.getString = this.getString.bind(this)\n    this.getNumber = this.getNumber.bind(this)\n    this.resolvePromise = this.resolvePromise.bind(this)\n  }\n\n  // @implement Disposable ----------------------------------------------------\n\n  get alive() {\n    return this.memory.alive\n  }\n\n  /**\n   * Dispose of this VM's underlying resources.\n   *\n   * @throws Calling this method without disposing of all created handles\n   * will result in an error.\n   */\n  dispose() {\n    this.memory.dispose()\n  }\n\n  // Globals ------------------------------------------------------------------\n\n  /**\n   * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).\n   */\n  get undefined(): QuickJSHandle {\n    if (this._undefined) {\n      return this._undefined\n    }\n\n    // Undefined is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetUndefined()\n    return (this._undefined = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).\n   */\n  get null(): QuickJSHandle {\n    if (this._null) {\n      return this._null\n    }\n\n    // Null is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetNull()\n    return (this._null = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).\n   */\n  get true(): QuickJSHandle {\n    if (this._true) {\n      return this._true\n    }\n\n    // True is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetTrue()\n    return (this._true = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).\n   */\n  get false(): QuickJSHandle {\n    if (this._false) {\n      return this._false\n    }\n\n    // False is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetFalse()\n    return (this._false = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).\n   * A handle to the global object inside the interpreter.\n   * You can set properties to create global variables.\n   */\n  get global(): QuickJSHandle {\n    if (this._global) {\n      return this._global\n    }\n\n    // The global is a JSValue, but since it's lifetime is as long as the VM's,\n    // we should manage it.\n    const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value)\n\n    // Automatically clean up this reference when we dispose\n    this.memory.manage(this.memory.heapValueHandle(ptr))\n\n    // This isn't technically a static lifetime, but since it has the same\n    // lifetime as the VM, it's okay to fake one since when the VM is\n    // disposed, no other functions will accept the value.\n    this._global = new StaticLifetime(ptr, this.runtime)\n    return this._global\n  }\n\n  // New values ---------------------------------------------------------------\n\n  /**\n   * Converts a Javascript number into a QuickJS value.\n   */\n  newNumber(num: number): QuickJSHandle {\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num))\n  }\n\n  /**\n   * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.\n   */\n  newString(str: string): QuickJSHandle {\n    const ptr = this.memory\n      .newHeapCharPointer(str)\n      .consume((charHandle) => this.ffi.QTS_NewString(this.ctx.value, charHandle.value))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.\n   * No two symbols created with this function will be the same value.\n   */\n  newUniqueSymbol(description: string | symbol): QuickJSHandle {\n    const key = (typeof description === \"symbol\" ? description.description : description) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(key)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 0))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.\n   * All symbols created with the same key will be the same value.\n   */\n  newSymbolFor(key: string | symbol): QuickJSHandle {\n    const description = (typeof key === \"symbol\" ? key.description : key) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(description)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 1))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.\n   */\n  newBigInt(num: bigint): QuickJSHandle {\n    if (!this._BigInt) {\n      const bigIntHandle = this.getProp(this.global, \"BigInt\")\n      this.memory.manage(bigIntHandle)\n      this._BigInt = new StaticLifetime(bigIntHandle.value as JSValueConstPointer, this.runtime)\n    }\n\n    const bigIntHandle = this._BigInt\n    const asString = String(num)\n    return this.newString(asString).consume((handle) =>\n      this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle))\n    )\n  }\n\n  /**\n   * `{}`.\n   * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).\n   *\n   * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).\n   */\n  newObject(prototype?: QuickJSHandle): QuickJSHandle {\n    if (prototype) {\n      this.runtime.assertOwned(prototype)\n    }\n    const ptr = prototype\n      ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype.value)\n      : this.ffi.QTS_NewObject(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * `[]`.\n   * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).\n   */\n  newArray(): QuickJSHandle {\n    const ptr = this.ffi.QTS_NewArray(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a new [[QuickJSDeferredPromise]]. Use `deferred.resolve(handle)` and\n   * `deferred.reject(handle)` to fulfill the promise handle available at `deferred.handle`.\n   * Note that you are responsible for calling `deferred.dispose()` to free the underlying\n   * resources; see the documentation on [[QuickJSDeferredPromise]] for details.\n   */\n  newPromise(): QuickJSDeferredPromise\n  /**\n   * Create a new [[QuickJSDeferredPromise]] that resolves when the\n   * given native Promise<QuickJSHandle> resolves. Rejections will be coerced\n   * to a QuickJS error.\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(promise: Promise<QuickJSHandle>): QuickJSDeferredPromise\n  /**\n   * Construct a new native Promise<QuickJSHandle>, and then convert it into a\n   * [[QuickJSDeferredPromise]].\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(\n    newPromiseFn: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle>\n  ): QuickJSDeferredPromise\n  newPromise(\n    value?: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle> | Promise<QuickJSHandle>\n  ): QuickJSDeferredPromise {\n    const deferredPromise = Scope.withScope((scope) => {\n      const mutablePointerArray = scope.manage(\n        this.memory.newMutablePointerArray<JSValuePointerPointer>(2)\n      )\n      const promisePtr = this.ffi.QTS_NewPromiseCapability(\n        this.ctx.value,\n        mutablePointerArray.value.ptr\n      )\n      const promiseHandle = this.memory.heapValueHandle(promisePtr)\n      const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map(\n        (jsvaluePtr) => this.memory.heapValueHandle(jsvaluePtr as any)\n      )\n      return new QuickJSDeferredPromise({\n        context: this,\n        promiseHandle,\n        resolveHandle,\n        rejectHandle,\n      })\n    })\n\n    if (value && typeof value === \"function\") {\n      value = new Promise(value)\n    }\n\n    if (value) {\n      Promise.resolve(value).then(deferredPromise.resolve, (error) =>\n        error instanceof Lifetime\n          ? deferredPromise.reject(error)\n          : this.newError(error).consume(deferredPromise.reject)\n      )\n    }\n\n    return deferredPromise\n  }\n\n  /**\n   * Convert a Javascript function into a QuickJS function value.\n   * See [[VmFunctionImplementation]] for more details.\n   *\n   * A [[VmFunctionImplementation]] should not free its arguments or its return\n   * value. A VmFunctionImplementation should also not retain any references to\n   * its return value.\n   *\n   * To implement an async function, create a promise with [[newPromise]], then\n   * return the deferred promise handle from `deferred.handle` from your\n   * function implementation:\n   *\n   * ```\n   * const deferred = vm.newPromise()\n   * someNativeAsyncFunction().then(deferred.resolve)\n   * return deferred.handle\n   * ```\n   */\n  newFunction(name: string, fn: VmFunctionImplementation<QuickJSHandle>): QuickJSHandle {\n    const fnId = ++this.fnNextId\n    this.setFunction(fnId, fn)\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name))\n  }\n\n  newError(error: { name: string; message: string }): QuickJSHandle\n  newError(message: string): QuickJSHandle\n  newError(): QuickJSHandle\n  newError(error?: string | { name: string; message: string }): QuickJSHandle {\n    const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value))\n\n    if (error && typeof error === \"object\") {\n      if (error.name !== undefined) {\n        this.newString(error.name).consume((handle) => this.setProp(errorHandle, \"name\", handle))\n      }\n\n      if (error.message !== undefined) {\n        this.newString(error.message).consume((handle) =>\n          this.setProp(errorHandle, \"message\", handle)\n        )\n      }\n    } else if (typeof error === \"string\") {\n      this.newString(error).consume((handle) => this.setProp(errorHandle, \"message\", handle))\n    } else if (error !== undefined) {\n      // This isn't supported in the type signature but maybe it will make life easier.\n      this.newString(String(error)).consume((handle) =>\n        this.setProp(errorHandle, \"message\", handle)\n      )\n    }\n\n    return errorHandle\n  }\n\n  // Read values --------------------------------------------------------------\n\n  /**\n   * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).\n   *\n   * @remarks\n   * Does not support BigInt values correctly.\n   */\n  typeof(handle: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript number.\n   * @returns `NaN` on error, otherwise a `number`.\n   */\n  getNumber(handle: QuickJSHandle): number {\n    this.runtime.assertOwned(handle)\n    return this.ffi.QTS_GetFloat64(this.ctx.value, handle.value)\n  }\n\n  /**\n   * Converts `handle` to a Javascript string.\n   */\n  getString(handle: QuickJSHandle): string {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript symbol. If the symbol is in the global\n   * registry in the guest, it will be created with Symbol.for on the host.\n   */\n  getSymbol(handle: QuickJSHandle): symbol {\n    this.runtime.assertOwned(handle)\n    const key = this.memory.consumeJSCharPointer(\n      this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle.value)\n    )\n    const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle.value)\n    return isGlobal ? Symbol.for(key) : Symbol(key)\n  }\n\n  /**\n   * Converts `handle` to a Javascript bigint.\n   */\n  getBigInt(handle: QuickJSHandle): bigint {\n    this.runtime.assertOwned(handle)\n    const asString = this.getString(handle)\n    return BigInt(asString)\n  }\n\n  /**\n   * `Promise.resolve(value)`.\n   * Convert a handle containing a Promise-like value inside the VM into an\n   * actual promise on the host.\n   *\n   * @remarks\n   * You may need to call [[executePendingJobs]] to ensure that the promise is resolved.\n   *\n   * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.\n   */\n  resolvePromise(promiseLikeHandle: QuickJSHandle): Promise<VmCallResult<QuickJSHandle>> {\n    this.runtime.assertOwned(promiseLikeHandle)\n    const vmResolveResult = Scope.withScope((scope) => {\n      const vmPromise = scope.manage(this.getProp(this.global, \"Promise\"))\n      const vmPromiseResolve = scope.manage(this.getProp(vmPromise, \"resolve\"))\n      return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle)\n    })\n    if (vmResolveResult.error) {\n      return Promise.resolve(vmResolveResult)\n    }\n\n    return new Promise<VmCallResult<QuickJSHandle>>((resolve) => {\n      Scope.withScope((scope) => {\n        const resolveHandle = scope.manage(\n          this.newFunction(\"resolve\", (value) => {\n            resolve({ value: value && value.dup() })\n          })\n        )\n\n        const rejectHandle = scope.manage(\n          this.newFunction(\"reject\", (error) => {\n            resolve({ error: error && error.dup() })\n          })\n        )\n\n        const promiseHandle = scope.manage(vmResolveResult.value)\n        const promiseThenHandle = scope.manage(this.getProp(promiseHandle, \"then\"))\n        this.unwrapResult(\n          this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle)\n        ).dispose()\n      })\n    })\n  }\n\n  // Properties ---------------------------------------------------------------\n\n  /**\n   * `handle[key]`.\n   * Get a property from a JSValue.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string (which will be converted automatically).\n   */\n  getProp(handle: QuickJSHandle, key: QuickJSPropertyKey): QuickJSHandle {\n    this.runtime.assertOwned(handle)\n    const ptr = this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_GetProp(this.ctx.value, handle.value, quickJSKey.value)\n    )\n    const result = this.memory.heapValueHandle(ptr)\n\n    return result\n  }\n\n  /**\n   * `handle[key] = value`.\n   * Set a property on a JSValue.\n   *\n   * @remarks\n   * Note that the QuickJS authors recommend using [[defineProp]] to define new\n   * properties.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  setProp(handle: QuickJSHandle, key: QuickJSPropertyKey, value: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    // free newly allocated value if key was a string or number. No-op if string was already\n    // a QuickJS handle.\n    this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_SetProp(this.ctx.value, handle.value, quickJSKey.value, value.value)\n    )\n  }\n\n  /**\n   * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  defineProp(\n    handle: QuickJSHandle,\n    key: QuickJSPropertyKey,\n    descriptor: VmPropertyDescriptor<QuickJSHandle>\n  ): void {\n    this.runtime.assertOwned(handle)\n    Scope.withScope((scope) => {\n      const quickJSKey = scope.manage(this.borrowPropertyKey(key))\n\n      const value = descriptor.value || this.undefined\n      const configurable = Boolean(descriptor.configurable)\n      const enumerable = Boolean(descriptor.enumerable)\n      const hasValue = Boolean(descriptor.value)\n      const get = descriptor.get\n        ? scope.manage(this.newFunction(descriptor.get.name, descriptor.get))\n        : this.undefined\n      const set = descriptor.set\n        ? scope.manage(this.newFunction(descriptor.set.name, descriptor.set))\n        : this.undefined\n\n      this.ffi.QTS_DefineProp(\n        this.ctx.value,\n        handle.value,\n        quickJSKey.value,\n        value.value,\n        get.value,\n        set.value,\n        configurable,\n        enumerable,\n        hasValue\n      )\n    })\n  }\n\n  // Evaluation ---------------------------------------------------------------\n\n  /**\n   * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).\n   * Call a JSValue as a function.\n   *\n   * See [[unwrapResult]], which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use [[resolvePromise]] to convert it to a native promise and\n   * [[executePendingJobs]] to finish evaluating the promise.\n   *\n   * @returns A result. If the function threw synchronously, `result.error` be a\n   * handle to the exception. Otherwise `result.value` will be a handle to the\n   * value.\n   */\n  callFunction(\n    func: QuickJSHandle,\n    thisVal: QuickJSHandle,\n    ...args: QuickJSHandle[]\n  ): VmCallResult<QuickJSHandle> {\n    this.runtime.assertOwned(func)\n    const resultPtr = this.memory\n      .toPointerArray(args)\n      .consume((argsArrayPtr) =>\n        this.ffi.QTS_Call(\n          this.ctx.value,\n          func.value,\n          thisVal.value,\n          args.length,\n          argsArrayPtr.value\n        )\n      )\n\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).\n   * Evaluates the Javascript source `code` in the global scope of this VM.\n   * When working with async code, you many need to call [[executePendingJobs]]\n   * to execute callbacks pending after synchronous evaluation returns.\n   *\n   * See [[unwrapResult]], which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use [[resolvePromise]] to convert it to a native promise and\n   * [[executePendingJobs]] to finish evaluating the promise.\n   *\n   * *Note*: to protect against infinite loops, provide an interrupt handler to\n   * [[setInterruptHandler]]. You can use [[shouldInterruptAfterDeadline]] to\n   * create a time-based deadline.\n   *\n   * @returns The last statement's value. If the code threw synchronously,\n   * `result.error` will be a handle to the exception. If execution was\n   * interrupted, the error will have name `InternalError` and message\n   * `interrupted`.\n   */\n  evalCode(\n    code: string,\n    filename: string = \"eval.js\",\n    /**\n     * If no options are passed, a heuristic will be used to detect if `code` is\n     * an ES module.\n     *\n     * See [[EvalFlags]] for number semantics.\n     */\n    options?: number | ContextEvalOptions\n  ): VmCallResult<QuickJSHandle> {\n    const detectModule = (options === undefined ? 1 : 0) as EvalDetectModule\n    const flags = evalOptionsToFlags(options) as EvalFlags\n    const resultPtr = this.memory\n      .newHeapCharPointer(code)\n      .consume((charHandle) =>\n        this.ffi.QTS_Eval(this.ctx.value, charHandle.value, filename, detectModule, flags)\n      )\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.\n   * @experimental\n   */\n  throw(error: Error | QuickJSHandle) {\n    return this.errorToHandle(error).consume((handle) =>\n      this.ffi.QTS_Throw(this.ctx.value, handle.value)\n    )\n  }\n\n  /**\n   * @private\n   */\n  protected borrowPropertyKey(key: QuickJSPropertyKey): QuickJSHandle {\n    if (typeof key === \"number\") {\n      return this.newNumber(key)\n    }\n\n    if (typeof key === \"string\") {\n      return this.newString(key)\n    }\n\n    // key is already a JSValue, but we're borrowing it. Return a static handle\n    // for internal use only.\n    return new StaticLifetime(key.value as JSValueConstPointer, this.runtime)\n  }\n\n  /**\n   * @private\n   */\n  getMemory(rt: JSRuntimePointer): ContextMemory {\n    if (rt === this.rt.value) {\n      return this.memory\n    } else {\n      throw new Error(\"Private API. Cannot get memory from a different runtime\")\n    }\n  }\n\n  // Utilities ----------------------------------------------------------------\n\n  /**\n   * Dump a JSValue to Javascript in a best-effort fashion.\n   * Returns `handle.toString()` if it cannot be serialized to JSON.\n   */\n  dump(handle: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    const type = this.typeof(handle)\n    if (type === \"string\") {\n      return this.getString(handle)\n    } else if (type === \"number\") {\n      return this.getNumber(handle)\n    } else if (type === \"bigint\") {\n      return this.getBigInt(handle)\n    } else if (type === \"undefined\") {\n      return undefined\n    } else if (type === \"symbol\") {\n      return this.getSymbol(handle)\n    }\n\n    const str = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle.value))\n    try {\n      return JSON.parse(str)\n    } catch (err) {\n      return str\n    }\n  }\n\n  /**\n   * Unwrap a SuccessOrFail result such as a [[VmCallResult]] or a\n   * [[ExecutePendingJobsResult]], where the fail branch contains a handle to a QuickJS error value.\n   * If the result is a success, returns the value.\n   * If the result is an error, converts the error to a native object and throws the error.\n   */\n  unwrapResult<T>(result: SuccessOrFail<T, QuickJSHandle>): T {\n    if (result.error) {\n      const context: QuickJSContext =\n        \"context\" in result.error ? (result.error as { context: QuickJSContext }).context : this\n      const cause = result.error.consume((error) => this.dump(error))\n\n      if (cause && typeof cause === \"object\" && typeof cause.message === \"string\") {\n        const { message, name, stack } = cause\n        const exception = new QuickJSUnwrapError(\"\")\n        const hostStack = exception.stack\n\n        if (typeof name === \"string\") {\n          exception.name = cause.name\n        }\n\n        if (typeof stack === \"string\") {\n          exception.stack = `${name}: ${message}\\n${cause.stack}Host: ${hostStack}`\n        }\n\n        Object.assign(exception, { cause, context, message })\n        throw exception\n      }\n\n      throw new QuickJSUnwrapError(cause, context)\n    }\n\n    return result.value\n  }\n\n  /** @private */\n  protected fnNextId = -32768 // min value of signed 16bit int used by Quickjs\n  /** @private */\n  protected fnMaps = new Map<number, Map<number, VmFunctionImplementation<QuickJSHandle>>>()\n\n  /** @private */\n  protected getFunction(fn_id: number): VmFunctionImplementation<QuickJSHandle> | undefined {\n    const map_id = fn_id >> 8\n    const fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      return undefined\n    }\n    return fnMap.get(fn_id)\n  }\n\n  /** @private */\n  protected setFunction(fn_id: number, handle: VmFunctionImplementation<QuickJSHandle>) {\n    const map_id = fn_id >> 8\n    let fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      fnMap = new Map<number, VmFunctionImplementation<QuickJSHandle>>()\n      this.fnMaps.set(map_id, fnMap)\n    }\n    return fnMap.set(fn_id, handle)\n  }\n\n  /**\n   * @hidden\n   */\n  private cToHostCallbacks: ContextCallbacks = {\n    callFunction: (ctx, this_ptr, argc, argv, fn_id) => {\n      if (ctx !== this.ctx.value) {\n        throw new Error(\"QuickJSContext instance received C -> JS call with mismatched ctx\")\n      }\n\n      const fn = this.getFunction(fn_id)\n      if (!fn) {\n        // this \"throw\" is not catch-able from the TS side. could we somehow handle this higher up?\n        throw new Error(`QuickJSContext had no callback with id ${fn_id}`)\n      }\n\n      return Scope.withScopeMaybeAsync(this, function* (awaited, scope) {\n        const thisHandle = scope.manage(\n          new WeakLifetime(this_ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime)\n        )\n        const argHandles = new Array<QuickJSHandle>(argc)\n        for (let i = 0; i < argc; i++) {\n          const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i)\n          argHandles[i] = scope.manage(\n            new WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime)\n          )\n        }\n\n        try {\n          const result = yield* awaited(fn.apply(thisHandle, argHandles))\n          if (result) {\n            if (\"error\" in result && result.error) {\n              debugLog(\"throw error\", result.error)\n              throw result.error\n            }\n            const handle = scope.manage(result instanceof Lifetime ? result : result.value)\n            return this.ffi.QTS_DupValuePointer(this.ctx.value, handle.value)\n          }\n          return 0 as JSValuePointer\n        } catch (error) {\n          return this.errorToHandle(error as Error).consume((errorHandle) =>\n            this.ffi.QTS_Throw(this.ctx.value, errorHandle.value)\n          )\n        }\n      }) as JSValuePointer\n    },\n  }\n\n  private errorToHandle(error: Error | QuickJSHandle): QuickJSHandle {\n    if (error instanceof Lifetime) {\n      return error\n    }\n\n    return this.newError(error)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}