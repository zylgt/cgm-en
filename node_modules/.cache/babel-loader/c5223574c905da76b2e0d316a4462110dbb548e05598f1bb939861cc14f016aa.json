{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ftp = void 0;\nconst basic_ftp_1 = require(\"basic-ftp\");\nconst stream_1 = require(\"stream\");\nconst path_1 = require(\"path\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst notfound_1 = __importDefault(require(\"./notfound\"));\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\nconst debug = (0, debug_1.default)('get-uri:ftp');\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n */\nconst ftp = async (url, opts = {}) => {\n  const {\n    cache\n  } = opts;\n  const filepath = decodeURIComponent(url.pathname);\n  let lastModified;\n  if (!filepath) {\n    throw new TypeError('No \"pathname\"!');\n  }\n  const client = new basic_ftp_1.Client();\n  try {\n    const host = url.hostname || url.host || 'localhost';\n    const port = parseInt(url.port || '0', 10) || 21;\n    const user = url.username ? decodeURIComponent(url.username) : undefined;\n    const password = url.password ? decodeURIComponent(url.password) : undefined;\n    await client.access({\n      host,\n      port,\n      user,\n      password,\n      ...opts\n    });\n    // first we have to figure out the Last Modified date.\n    // try the MDTM command first, which is an optional extension command.\n    try {\n      lastModified = await client.lastMod(filepath);\n    } catch (err) {\n      // handle the \"file not found\" error code\n      if (err.code === 550) {\n        throw new notfound_1.default();\n      }\n    }\n    if (!lastModified) {\n      // Try to get the last modified date via the LIST command (uses\n      // more bandwidth, but is more compatible with older FTP servers\n      const list = await client.list((0, path_1.dirname)(filepath));\n      // attempt to find the \"entry\" with a matching \"name\"\n      const name = (0, path_1.basename)(filepath);\n      const entry = list.find(e => e.name === name);\n      if (entry) {\n        lastModified = entry.modifiedAt;\n      }\n    }\n    if (lastModified) {\n      if (isNotModified()) {\n        throw new notmodified_1.default();\n      }\n    } else {\n      throw new notfound_1.default();\n    }\n    const stream = new stream_1.PassThrough();\n    const rs = stream;\n    client.downloadTo(stream, filepath).then(result => {\n      debug(result.message);\n      client.close();\n    });\n    rs.lastModified = lastModified;\n    return rs;\n  } catch (err) {\n    client.close();\n    throw err;\n  }\n  // called when `lastModified` is set, and a \"cache\" stream was provided\n  function isNotModified() {\n    if (cache?.lastModified && lastModified) {\n      return +cache.lastModified === +lastModified;\n    }\n    return false;\n  }\n};\nexports.ftp = ftp;","map":{"version":3,"names":["basic_ftp_1","require","stream_1","path_1","debug_1","__importDefault","notfound_1","notmodified_1","debug","default","ftp","url","opts","cache","filepath","decodeURIComponent","pathname","lastModified","TypeError","client","Client","host","hostname","port","parseInt","user","username","undefined","password","access","lastMod","err","code","list","dirname","name","basename","entry","find","e","modifiedAt","isNotModified","stream","PassThrough","rs","downloadTo","then","result","message","close","exports"],"sources":["../src/ftp.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;AAAA,MAAAA,WAAA,GAAAC,OAAA;AACA,MAAAC,QAAA,GAAAD,OAAA;AACA,MAAAE,MAAA,GAAAF,OAAA;AACA,MAAAG,OAAA,GAAAC,eAAA,CAAAJ,OAAA;AACA,MAAAK,UAAA,GAAAD,eAAA,CAAAJ,OAAA;AACA,MAAAM,aAAA,GAAAF,eAAA,CAAAJ,OAAA;AAGA,MAAMO,KAAK,GAAG,IAAAJ,OAAA,CAAAK,OAAW,EAAC,aAAa,CAAC;AAUxC;;;AAGO,MAAMC,GAAG,GAA+B,MAAAA,CAAOC,GAAG,EAAEC,IAAI,GAAG,EAAE,KAAI;EACvE,MAAM;IAAEC;EAAK,CAAE,GAAGD,IAAI;EACtB,MAAME,QAAQ,GAAGC,kBAAkB,CAACJ,GAAG,CAACK,QAAQ,CAAC;EACjD,IAAIC,YAA8B;EAElC,IAAI,CAACH,QAAQ,EAAE;IACd,MAAM,IAAII,SAAS,CAAC,gBAAgB,CAAC;;EAGtC,MAAMC,MAAM,GAAG,IAAInB,WAAA,CAAAoB,MAAM,EAAE;EAE3B,IAAI;IACH,MAAMC,IAAI,GAAGV,GAAG,CAACW,QAAQ,IAAIX,GAAG,CAACU,IAAI,IAAI,WAAW;IACpD,MAAME,IAAI,GAAGC,QAAQ,CAACb,GAAG,CAACY,IAAI,IAAI,GAAG,EAAE,EAAE,CAAC,IAAI,EAAE;IAChD,MAAME,IAAI,GAAGd,GAAG,CAACe,QAAQ,GACtBX,kBAAkB,CAACJ,GAAG,CAACe,QAAQ,CAAC,GAChCC,SAAS;IACZ,MAAMC,QAAQ,GAAGjB,GAAG,CAACiB,QAAQ,GAC1Bb,kBAAkB,CAACJ,GAAG,CAACiB,QAAQ,CAAC,GAChCD,SAAS;IAEZ,MAAMR,MAAM,CAACU,MAAM,CAAC;MACnBR,IAAI;MACJE,IAAI;MACJE,IAAI;MACJG,QAAQ;MACR,GAAGhB;KACH,CAAC;IAEF;IACA;IACA,IAAI;MACHK,YAAY,GAAG,MAAME,MAAM,CAACW,OAAO,CAAChB,QAAQ,CAAC;KAC7C,CAAC,OAAOiB,GAAY,EAAE;MACtB;MACA,IAAKA,GAAwB,CAACC,IAAI,KAAK,GAAG,EAAE;QAC3C,MAAM,IAAI1B,UAAA,CAAAG,OAAa,EAAE;;;IAI3B,IAAI,CAACQ,YAAY,EAAE;MAClB;MACA;MACA,MAAMgB,IAAI,GAAG,MAAMd,MAAM,CAACc,IAAI,CAAC,IAAA9B,MAAA,CAAA+B,OAAO,EAACpB,QAAQ,CAAC,CAAC;MAEjD;MACA,MAAMqB,IAAI,GAAG,IAAAhC,MAAA,CAAAiC,QAAQ,EAACtB,QAAQ,CAAC;MAC/B,MAAMuB,KAAK,GAAGJ,IAAI,CAACK,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAACJ,IAAI,KAAKA,IAAI,CAAC;MAC/C,IAAIE,KAAK,EAAE;QACVpB,YAAY,GAAGoB,KAAK,CAACG,UAAU;;;IAIjC,IAAIvB,YAAY,EAAE;MACjB,IAAIwB,aAAa,EAAE,EAAE;QACpB,MAAM,IAAIlC,aAAA,CAAAE,OAAgB,EAAE;;KAE7B,MAAM;MACN,MAAM,IAAIH,UAAA,CAAAG,OAAa,EAAE;;IAG1B,MAAMiC,MAAM,GAAG,IAAIxC,QAAA,CAAAyC,WAAW,EAAE;IAChC,MAAMC,EAAE,GAAGF,MAAqB;IAChCvB,MAAM,CAAC0B,UAAU,CAACH,MAAM,EAAE5B,QAAQ,CAAC,CAACgC,IAAI,CAAEC,MAAM,IAAI;MACnDvC,KAAK,CAACuC,MAAM,CAACC,OAAO,CAAC;MACrB7B,MAAM,CAAC8B,KAAK,EAAE;IACf,CAAC,CAAC;IACFL,EAAE,CAAC3B,YAAY,GAAGA,YAAY;IAC9B,OAAO2B,EAAE;GACT,CAAC,OAAOb,GAAG,EAAE;IACbZ,MAAM,CAAC8B,KAAK,EAAE;IACd,MAAMlB,GAAG;;EAGV;EACA,SAASU,aAAaA,CAAA;IACrB,IAAI5B,KAAK,EAAEI,YAAY,IAAIA,YAAY,EAAE;MACxC,OAAO,CAACJ,KAAK,CAACI,YAAY,KAAK,CAACA,YAAY;;IAE7C,OAAO,KAAK;EACb;AACD,CAAC;AAjFYiC,OAAA,CAAAxC,GAAG,GAAAA,GAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}