{"ast":null,"code":"import jsPDF from 'jspdf';\nimport html2canvas from 'html2canvas';\n\n/*\n * 使用说明\n * ele:需要导出pdf的容器元素(dom节点 不是id)\n * pdfFileName: 导出文件的名字 通过调用outPutPdfFn方法也可传参数改变\n * splitClassName: 避免分段截断的类名 当pdf有多页时需要传入此参数 , 避免pdf分页时截断元素  如表格<tr class=\"itemClass\"></tr>\n * 调用方式 先 let pdf = new PdfLoader(ele, 'pdf' ,'itemClass');\n * 若想改变pdf名称 pdf.outPutPdfFn(fileName);  outPutPdfFn方法返回一个promise 可以使用then方法处理pdf生成后的逻辑\n * */\nclass PdfLoader {\n  constructor(ele, pdfFileName, splitClassName) {\n    this.ele = ele;\n    this.pdfFileName = pdfFileName;\n    this.splitClassName = splitClassName || '';\n    this.A4_WIDTH = 841.89;\n    this.A4_HEIGHT = 595.28;\n  }\n  async getPDF(resolve) {\n    const ele = this.ele;\n    const pdfFileName = this.pdfFileName;\n    const eleW = ele.offsetWidth; // 获得该容器的宽\n    const eleH = ele.scrollHeight; // 获得该容器的高\n    const eleOffsetTop = ele.offsetTop; // 获得该容器到文档顶部的距离\n    const eleOffsetLeft = ele.offsetLeft; // 获得该容器到文档最左的距离\n    window.pageYoffset = 0;\n    document.documentElement.scrollTop = 0;\n    document.body.scrollTop = 0;\n    const canvas = document.createElement('canvas');\n    let abs = 0;\n    const win_in = document.documentElement.clientWidth || document.body.clientWidth; // 获得当前可视窗口的宽度（不包含滚动条）\n    const win_out = window.innerWidth; // 获得当前窗口的宽度（包含滚动条）\n    if (win_out > win_in) {\n      abs = (win_out - win_in) / 2; // 获得滚动条宽度的一半\n    }\n    canvas.width = eleW * 2; // 将画布宽&&高放大两倍\n    canvas.height = eleH * 2;\n    const context = canvas.getContext('2d');\n    context.scale(2, 2); // 增强图片清晰度\n    context.translate(-eleOffsetLeft - abs, -eleOffsetTop);\n    ele.style.height = ele.scrollHeight + 'px'; // 获取元素的滚动高度，用于截取被滚动条隐藏的部分\n    html2canvas(ele, {\n      backgroundColor: null,\n      allowTaint: false,\n      dpi: window.devicePixelRatio * 4,\n      width: ele.width,\n      height: ele.width,\n      windowWidth: ele.scrollWidth,\n      scale: 4,\n      // 按比例增加分辨率\n      useCORS: true // 允许canvas画布内可以跨域请求外部链接图片, 允许跨域请求。\n    }).then(async canvas => {\n      const contentWidth = canvas.width;\n      const contentHeight = canvas.height;\n      ele.style.height = ele.clientHeight + 'px'; // 获取元素的实际高度，不包括滚动条隐藏的部分\n      // 一页pdf显示html页面生成的canvas高度;\n      const pageHeight = contentWidth / this.A4_WIDTH * this.A4_HEIGHT; // 这样写的目的在于保持宽高比例一致 pageHeight/canvas.width = a4纸高度/a4纸宽度// 宽度和canvas.width保持一致\n      // 未生成pdf的html页面高度\n      let leftHeight = contentHeight;\n      // 页面偏移\n      let position = 0;\n      // a4纸的尺寸[595,842],单位像素，html页面生成的canvas在pdf中图片的宽高\n      const imgWidth = this.A4_WIDTH - 50; // -10为了页面有右边距\n      const imgHeight = this.A4_WIDTH / contentWidth * contentHeight;\n      const pageData = canvas.toDataURL('image/jpeg', 1.0);\n      const pdf = jsPDF('l', 'pt', 'a4');\n      // 有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)\n      // 当内容未超过pdf一页显示的范围，无需分页\n      if (leftHeight < pageHeight) {\n        // 在pdf.addImage(pageData, 'JPEG', 左，上，宽度，高度)设置在pdf中显示；\n        pdf.addImage(pageData, 'JPEG', 5, 0, imgWidth, imgHeight);\n        // pdf.addImage(pageData, 'JPEG', 20, 40, imgWidth, imgHeight);\n      } else {\n        // 分页\n        while (leftHeight > 0) {\n          pdf.addImage(pageData, 'JPEG', 5, position, imgWidth, imgHeight);\n          leftHeight -= pageHeight;\n          position -= this.A4_HEIGHT;\n          // 避免添加空白页\n          if (leftHeight > 0) {\n            pdf.addPage();\n          }\n        }\n      }\n      pdf.save(pdfFileName + '.pdf', {\n        returnPromise: true\n      }).then(() => {\n        // 去除添加的空div 防止页面混乱\n        const doms = document.querySelectorAll('.emptyDiv');\n        for (let i = 0; i < doms.length; i++) {\n          doms[i].remove();\n        }\n      });\n      this.ele.style.height = '';\n      resolve();\n    });\n  }\n  //此方法是防止（图表之类）内容因为A4纸张问题被截断\n  async outPutPdfFn(pdfFileName) {\n    return new Promise((resolve, reject) => {\n      this.ele.style.height = 'initial';\n      pdfFileName ? this.pdfFileName = pdfFileName : null;\n      const target = this.ele;\n      const pageHeight = target.scrollWidth / this.A4_WIDTH * this.A4_HEIGHT;\n      // 获取分割dom，此处为class类名为item的dom\n      const domList = document.getElementsByClassName(this.splitClassName);\n      // 进行分割操作，当dom内容已超出a4的高度，则将该dom前插入一个空dom，把他挤下去，分割\n      let pageNum = 1; // pdf页数\n      const eleBounding = this.ele.getBoundingClientRect();\n      for (let i = 0; i < domList.length; i++) {\n        const node = domList[i];\n        const bound = node.getBoundingClientRect();\n        const offset2Ele = bound.top - eleBounding.top;\n        const currentPage = Math.ceil((bound.bottom - eleBounding.top) / pageHeight); // 当前元素应该在哪一页\n        if (pageNum < currentPage) {\n          pageNum++;\n          const divParent = domList[i].parentNode; // 获取该div的父节点\n          const newNode = document.createElement('div');\n          newNode.className = 'emptyDiv';\n          newNode.style.background = 'white';\n          newNode.style.height = pageHeight * (pageNum - 1) - offset2Ele + 30 + 'px'; // +30为了在换下一页时有顶部的边距\n          newNode.style.width = '100%';\n          divParent.insertBefore(newNode, node); //在每一个节点前面插入一个空的新节点，防止内容被分割截断\n        }\n      }\n      // 异步函数，导出成功后处理交互\n      this.getPDF(resolve, reject);\n    });\n  }\n}\nexport default PdfLoader;","map":{"version":3,"names":["jsPDF","html2canvas","PdfLoader","constructor","ele","pdfFileName","splitClassName","A4_WIDTH","A4_HEIGHT","getPDF","resolve","eleW","offsetWidth","eleH","scrollHeight","eleOffsetTop","offsetTop","eleOffsetLeft","offsetLeft","window","pageYoffset","document","documentElement","scrollTop","body","canvas","createElement","abs","win_in","clientWidth","win_out","innerWidth","width","height","context","getContext","scale","translate","style","backgroundColor","allowTaint","dpi","devicePixelRatio","windowWidth","scrollWidth","useCORS","then","contentWidth","contentHeight","clientHeight","pageHeight","leftHeight","position","imgWidth","imgHeight","pageData","toDataURL","pdf","addImage","addPage","save","returnPromise","doms","querySelectorAll","i","length","remove","outPutPdfFn","Promise","reject","target","domList","getElementsByClassName","pageNum","eleBounding","getBoundingClientRect","node","bound","offset2Ele","top","currentPage","Math","ceil","bottom","divParent","parentNode","newNode","className","background","insertBefore"],"sources":["/Users/hexuemin/Desktop/jiuan/CGM/CGMWeb/src/utils/export/html2pdf.js"],"sourcesContent":["import jsPDF from 'jspdf'\nimport html2canvas from 'html2canvas'\n \n/*\n * 使用说明\n * ele:需要导出pdf的容器元素(dom节点 不是id)\n * pdfFileName: 导出文件的名字 通过调用outPutPdfFn方法也可传参数改变\n * splitClassName: 避免分段截断的类名 当pdf有多页时需要传入此参数 , 避免pdf分页时截断元素  如表格<tr class=\"itemClass\"></tr>\n * 调用方式 先 let pdf = new PdfLoader(ele, 'pdf' ,'itemClass');\n * 若想改变pdf名称 pdf.outPutPdfFn(fileName);  outPutPdfFn方法返回一个promise 可以使用then方法处理pdf生成后的逻辑\n * */\nclass PdfLoader {\n    constructor(ele, pdfFileName, splitClassName) {\n        this.ele = ele\n        this.pdfFileName = pdfFileName\n        this.splitClassName = splitClassName || ''\n        this.A4_WIDTH = 841.89\n        this.A4_HEIGHT = 595.28\n    }\n \n    async getPDF(resolve) {\n        const ele = this.ele\n        const pdfFileName = this.pdfFileName\n        const eleW = ele.offsetWidth // 获得该容器的宽\n        const eleH = ele.scrollHeight // 获得该容器的高\n        const eleOffsetTop = ele.offsetTop // 获得该容器到文档顶部的距离\n        const eleOffsetLeft = ele.offsetLeft // 获得该容器到文档最左的距离\n        window.pageYoffset = 0\n        document.documentElement.scrollTop = 0\n        document.body.scrollTop = 0\n        const canvas = document.createElement('canvas')\n        let abs = 0\n        const win_in =\n            document.documentElement.clientWidth || document.body.clientWidth // 获得当前可视窗口的宽度（不包含滚动条）\n        const win_out = window.innerWidth // 获得当前窗口的宽度（包含滚动条）\n        if (win_out > win_in) {\n            abs = (win_out - win_in) / 2 // 获得滚动条宽度的一半\n        }\n        canvas.width = eleW * 2 // 将画布宽&&高放大两倍\n        canvas.height = eleH * 2\n        const context = canvas.getContext('2d')\n        context.scale(2, 2) // 增强图片清晰度\n        context.translate(-eleOffsetLeft - abs, -eleOffsetTop)\n        ele.style.height = ele.scrollHeight + 'px' // 获取元素的滚动高度，用于截取被滚动条隐藏的部分\n        html2canvas(ele, {\n            backgroundColor: null,\n            allowTaint: false,\n            dpi: window.devicePixelRatio * 4,\n            width: ele.width,\n            height: ele.width,\n            windowWidth: ele.scrollWidth,\n            scale: 4, // 按比例增加分辨率\n            useCORS: true, // 允许canvas画布内可以跨域请求外部链接图片, 允许跨域请求。\n        }).then(async (canvas) => {\n            const contentWidth = canvas.width\n            const contentHeight = canvas.height\n            ele.style.height = ele.clientHeight + 'px' // 获取元素的实际高度，不包括滚动条隐藏的部分\n            // 一页pdf显示html页面生成的canvas高度;\n            const pageHeight = (contentWidth / this.A4_WIDTH) * this.A4_HEIGHT // 这样写的目的在于保持宽高比例一致 pageHeight/canvas.width = a4纸高度/a4纸宽度// 宽度和canvas.width保持一致\n            // 未生成pdf的html页面高度\n            let leftHeight = contentHeight\n            // 页面偏移\n            let position = 0\n            // a4纸的尺寸[595,842],单位像素，html页面生成的canvas在pdf中图片的宽高\n            const imgWidth = this.A4_WIDTH - 50 // -10为了页面有右边距\n            const imgHeight = (this.A4_WIDTH / contentWidth) * contentHeight\n            const pageData = canvas.toDataURL('image/jpeg', 1.0)\n            const pdf = jsPDF('l', 'pt', 'a4')\n            // 有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)\n            // 当内容未超过pdf一页显示的范围，无需分页\n            if (leftHeight < pageHeight) {\n                // 在pdf.addImage(pageData, 'JPEG', 左，上，宽度，高度)设置在pdf中显示；\n                pdf.addImage(pageData, 'JPEG', 5, 0, imgWidth, imgHeight)\n                // pdf.addImage(pageData, 'JPEG', 20, 40, imgWidth, imgHeight);\n            } else {\n                // 分页\n                while (leftHeight > 0) {\n                    pdf.addImage(\n                        pageData,\n                        'JPEG',\n                        5,\n                        position,\n                        imgWidth,\n                        imgHeight\n                    )\n                    leftHeight -= pageHeight\n                    position -= this.A4_HEIGHT\n                    // 避免添加空白页\n                    if (leftHeight > 0) {\n                        pdf.addPage()\n                    }\n                }\n            }\n            pdf.save(pdfFileName + '.pdf', { returnPromise: true }).then(() => {\n                // 去除添加的空div 防止页面混乱\n                const doms = document.querySelectorAll('.emptyDiv')\n                for (let i = 0; i < doms.length; i++) {\n                    doms[i].remove()\n                }\n            })\n            this.ele.style.height = ''\n            resolve()\n        })\n    }\n    //此方法是防止（图表之类）内容因为A4纸张问题被截断\n    async outPutPdfFn(pdfFileName) {\n        return new Promise((resolve, reject) => {\n            this.ele.style.height = 'initial'\n            pdfFileName ? (this.pdfFileName = pdfFileName) : null\n            const target = this.ele\n            const pageHeight =\n                (target.scrollWidth / this.A4_WIDTH) * this.A4_HEIGHT\n            // 获取分割dom，此处为class类名为item的dom\n            const domList = document.getElementsByClassName(this.splitClassName)\n            // 进行分割操作，当dom内容已超出a4的高度，则将该dom前插入一个空dom，把他挤下去，分割\n            let pageNum = 1 // pdf页数\n            const eleBounding = this.ele.getBoundingClientRect()\n            for (let i = 0; i < domList.length; i++) {\n                const node = domList[i]\n                const bound = node.getBoundingClientRect()\n                const offset2Ele = bound.top - eleBounding.top\n                const currentPage = Math.ceil(\n                    (bound.bottom - eleBounding.top) / pageHeight\n                ) // 当前元素应该在哪一页\n                if (pageNum < currentPage) {\n                    pageNum++\n                    const divParent = domList[i].parentNode // 获取该div的父节点\n                    const newNode = document.createElement('div')\n                    newNode.className = 'emptyDiv'\n                    newNode.style.background = 'white'\n                    newNode.style.height =\n                        pageHeight * (pageNum - 1) - offset2Ele + 30 + 'px' // +30为了在换下一页时有顶部的边距\n                    newNode.style.width = '100%'\n                    divParent.insertBefore(newNode, node) //在每一个节点前面插入一个空的新节点，防止内容被分割截断\n                }\n            }\n            // 异步函数，导出成功后处理交互\n            this.getPDF(resolve, reject)\n        })\n    }\n}\n \nexport default PdfLoader"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}